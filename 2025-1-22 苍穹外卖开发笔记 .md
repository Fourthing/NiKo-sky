# 苍穹外卖开发笔记

## Day 1

### 软件开发整体介绍

#### 1）软件开发工程

**需求分析**（需求规格说明书、产品原型）→ **设计**（UI设计、数据库设计、**接口**设计）→ **编码**（项目代码、单元测试）→ **测试**（测试用例和报告） → 上线**运维**（软件环境安装、配置）

#### 2）角色分工

项目经理、产品经理、UI设计师、架构师、开发工程师、测试工程师、

#### 3）软件环境

- 开发环境（development）：内部的开发环境，外部用户无法访问
- 测试环境（testing）：内部的测试环境，外部用户无法访问
- 生产环境（production）：即线上环境，正式**对外提供服务**的环境。

---

### 苍穹外卖项目介绍

- 项目介绍

  - 定位：专门为餐饮企业（餐厅、饭店）定制的一款软件产品。

  - 功能架构：

    分管理端和用户端。

    ![image-20241128095941824](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411280959879.png)

- 产品原型

- 技术选型

  展示项目中使用到的技术框架和中间件等。

  ![image-20241128101322685](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411281013731.png)

---

### 开发环境搭建

#### 前端环境搭建

前端有管理端（Web）和用户端（小程序）两部分，前端工程基于nginx运行。nginx的运行目录下不能有中文。

#### 后端环境搭建

后端工程基于`maven`进行项目构建，并且进行**分模块**开发。初始的功能只包括登录。

![image-20241128103115062](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411281031137.png)

![image-20241128103329591](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411281033636.png)

##### 使用Git进行版本控制

这里不用命令行语句，而是使用IDEA自带的VCS（版本控制）菜单就能帮我们完成版本控制流程。（当然远程仓库还是要自己创建的）。提交、推送、拉取都能做。

##### 数据库环境搭建

通过数据库建表语句（用一个`.sql`文件完成）创建数据库结构。详细的表结构参照`数据库设计文档.md`                             

##### 做一个前后端联调测试**（主要学习调试方法）**      

![image-20241128105939257](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411281059299.png)

首先需要检查编译是否通过（这里发现JDK22版本编不过，使用jdk17才行，到项目结构里改）。

> 学到了一个新的IDEA的操作tip，直接在Maven侧页中完成编译操作（点击图中的compile）：
>
> ![屏幕截图 2024-11-28 110024](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411281102188.png)

其次要学会**断点跟踪**的调试方式（debug），比如说对于登录功能设置断点：

![image-20241128123809687](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411281238726.png)

可以看到传入了参数：用户名和密码

![image-20241128123728278](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411281237356.png)

还有步过、步入、步出(从左到右依次对应)这些操作:![image-20241128124207497](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411281242529.png)

![image-20241128123908732](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411281239765.png)

> 1. **步过（Step Over）**：
>    - 当你使用“步过”功能时，调试器会执行当前行代码，但如果当前行调用了其他函数，则调试器不会进入该函数内部，而是直接执行完这行代码并停在下一行。这样可以帮助你跳过不需要关注的函数内部实现，专注于高层逻辑。
> 2. **步入（Step Into）**：
>    - 选择“步入”会导致调试器进入当前行代码所调用的函数内部。这对于需要详细查看函数内部逻辑的情况非常有用，能够逐步跟踪每一行代码的执行。
> 3. **步出（Step Out）**：
>    - 如果你在一个函数内部并希望返回到调用该函数的地方，可以使用“步出”。这个操作将执行完函数剩余的代码并返回到上一级调用的下一行，适用于当你已经完成对函数内部的调试，想要返回到更高层次的代码时。

点击“步进”后进入下一条语句，又学到了一个新操作：`Ctrl+Alt+点击对应方法`进入对应impl，如果是`Ctrl+点击对应方法`会进入接口中的方法（这是在两者都存在的情况下）。

然后是重新启动、停止、恢复程序（resume）、暂停的功能“：![image-20241128124508192](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411281245220.png)

其中resume的作用其实就是放行，一直让程序运行到下个断点。

##### Nginx反向代理与负载均衡简单理解

![image-20241128142026779](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411281420821.png)

实际上Nginx又可以当普通的Http服务器，也可以当反向代理的Web服务器。

前端请求的地址和后端接口的地址不一样，哪前端的请求又是怎么请求到后端服务的？![image-20241128141904380](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411281419433.png)

实际是通过nginx的反向代理实现的，前端的请求实际请求了Nginx服务器，再由nginx的反向代理再转发请求到后端。

![image-20241128142211271](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411281422310.png)

nginx的反向代理的第一个好处是**提高访问速度**，因为Nginx会**缓存**同路径地址，再次访问后端的时候只需要把缓存数据发回前端就好了，无需真正访问后端；

第二个好处是可以做**负载均衡**，这个是在大量请求高并发的场景下才的一个功能，可以把大量的请求按照指定的方式均衡（不一定平均）地分配给集群中的每台服务器。**负载均衡的本质也是转发请求**（基于反向代理）。

第三个好处是可以**保证后端服务安全**，也就是说前端的访问是不能够直接访问后端的，后端的服务是不直接暴露给互联网的，通常是部署在局域网，Nginx就好像一个门卫，处理前端的请求（就好像外卖小哥），再决定是否给后端（点外卖的人），当然后面这步走的是内网。

**反向代理配置**

![image-20241128143239682](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411281432732.png)

**负载均衡配置**

![image-20241128143437214](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411281434260.png)

**负载均衡策略**

![image-20241128143605209](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411281436258.png)

#### 完善登录功能

下面来做一些更贴近实际企业使用的登录优化。首先是密码的明文存储问题。

一个解决方案是用MD5算法来散列密码，效果如下（注意，这个过程是单向的，这也一定程度上解释了为什么忘记密码一定要输入一个新的密码）：

![image-20241128144152274](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411281441310.png)

> 需要注意的是MD5有可能被碰撞破解，高度安全性的数据可以使用SHA-2等其他算法。

好在Spring已经提供了一个方法来实现MD5算法，那就是`DigestUtils`的`md5DigestAsHex()`方法。

![image-20241128160416152](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411281604195.png)

 这里又学到一个新知识：

利用注释的TODO标签来标识尚要完成的任务。当有多个任务的时候方便自己来定位具体的位置。

> 如果没找到TODO，在这里可以添加。

![image-20241128162607926](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411281626966.png)

这是修改前的代码：

![image-20241128162827212](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411281628257.png)

```java
 //密码比对
        // TODO 后期需要进行md5加密，然后再进行比对
        if (!password.equals(employee.getPassword())) {
            //密码错误
            throw new PasswordErrorException(MessageConstant.PASSWORD_ERROR);
        }
```

修改后：

```java
//密码比对
        //对前端传过来的明文密码进行md5处理
        password=DigestUtils.md5DigestAsHex(password.getBytes());

        if (!password.equals(employee.getPassword())) {
            //密码错误
            throw new PasswordErrorException(MessageConstant.PASSWORD_ERROR);
        }
```

再次进行调试测试，发现一个错误：修改数据库中的数据之后没点确定（打勾符号），导致访问到的仍然是旧的数据。还是要细心一点。

---

### 导入**接口文档**

这也是非常重要的一步，定义好的接口是我们后端开发的依据。而且根据接口的合理性和实际开发的难度确定接口文档是否返工。

#### 前后端分离开发流程

![image-20241128164453222](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411281644274.png)

接口的管理平台使用的是免费开源的YApi，其他的还有Eolinker、ShowDoc、DOClever、RAP2、apifox等等。自己用的是Apifox，确实比较友好。

![image-20241128193734718](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411281937843.png)

![image-20241128193744061](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411281937117.png)

---

### Swagger

接口写好了如何测试呢？postman是一种选择。但面对多参数的情况比较乏力。

接下来学习一个新工具，叫做Swagger，只要按照它的规范去定义接口及接口相关的信息，就可以做到生成接口文档，以及在线接口调试页面。

还有一个搭配食用的框架叫做**Knife4j**，是针对Java MVC框架集成Swagger生成Api文档的增强解决方案。在Maven中导入方法如下：

![image-20241128194344163](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411281943209.png)

接下来有两步，第一步是在配置类中加入knife4j相关配置，第二步是设置静态资源映射，否则接口文档页面无法访问。

```java
//最重要的一句 ↓ 如果没有这一句，尽管Api静态文档页面能显示，但是由于没有识别控制类，文档会没有内容
             .apis(RequestHandlerSelectors.basePackage("com.sky.controller"))
```

```java
//如果没有这个方法里的代码，spring框架不会认为是在访问一个接口文档，而是一个控制器
log.info("开始设置静态资源映射...");
//自动用knife4j生成的文档，可以在浏览器中访问
registry.addResourceHandler("/doc.html").addResourceLocations("classpath:/META-INF/resources/");
registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/META-INF/resources/webjars/");
```

接下来看一看常用的注解，通过注解可以控制生成的接口文档，使接口文档拥有更好的可读性，

![image-20241128200910893](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411282009943.png)

比如：

```java
/**
* 退出
*
* @return
*/
@PostMapping("/logout")
@ApiOperation(value="员工注销")
public Result<String> logout() {
	return Result.success();
}     
```

在VO和DTO里的添加方法和效果类似。

---

## Day 2

### 新增员工

#### 需求分析与设计

![image-20241129145915425](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411291459568.png)

产品原型如上，初步分析之后使用JSON数据格式和POST方式来提交数据。

![image-20241129150358871](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411291503933.png)

接口文档如图，Path中的admin表示是从管理端发出的请求。

请求示例：

```json
{
    "id": 0,
    "idNumber": "string",
    "name": "string",
    "phone": "string",
    "sex": "string",
    "username": "string"
}
```

![image-20241129150511149](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411291505206.png)

返回响应如图，示例：

```json
{
    "code": 0,
    "data": {},
    "msg": "string"
}
```

最后熟悉一下数据库结构：

![image-20241129150957944](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411291509999.png)

这是employee表，其中的username（不是name）用户名设置为unique。

#### 代码开发

首先需要封装一下前端提交的数据，设计一个DTO。前端数据结构见前面的body，格式是JSON。（当然可以使用实体类来接收数据，但如果前端提交的数据和实体类中对应的属性差别比较大时，建议使用DTO来封装数据）

起名叫做EmployeeDTO（注意这个Data注解，使用 `@Data` 注解可以自动生成一些常用的方法而不用自己写）：

```java
@Data
public class EmployeeDTO implements Serializable {

    private Long id;

    private String username;

    private String name;

    private String phone;

    private String sex;

    private String idNumber;

}
```

然后我们就需要在controller里开发具体逻辑了，声明一个新方法叫做save（），用于新增员工

```java
	/**
     * 新增员工
     * @param employeeDTO
     * @return
     */
    @PostMapping
    @ApiOperation("新增员工")
    public Result save(@RequestBody EmployeeDTO employeeDTO) {
        log.info("新增员工：{}", employeeDTO);
        employeeService.save(employeeDTO);
        return Result.success();
    }
```

开头的注解是新的IDEA小知识，打出`/**+enter`会自动识别param生成这样的注释段。

用的是post方法，故使用`@PostMapping`注解；添加接口文档对应的注释，使用`@ApiOperation`注解。

方法内log.info输出一段信息，其中的{}是占位符。内容是后面的employeeDTO。

调用具体的service方法save（这里当然还是没有创建save方法的），下一步就是去service层创建一个save方法并实现。最后返回一个封装好的Result。

接下来是service层，首先是在接口中声明：

```java
	/**
     * 新增员工
     * @param employeeDTO
     */
    void save(EmployeeDTO employeeDTO);
```

再接着在对应的impl中完成实现：

```java
/**
     * 新增员工
     * @param employeeDTO
     */
    public void save(EmployeeDTO employeeDTO) {
        Employee employee = new Employee();

        //一个一个属性赋值太麻烦
        //使用对象属性拷贝(属性名必须一致)
        BeanUtils.copyProperties(employeeDTO,employee);

        //设置账号的状态，默认正常状态 1表示正常，0表示锁定
        //不能硬编码，所以使用常量类
        employee.setStatus(StatusConstant.ENABLE);

        //设置账号的默认密码，默认密码123456
        //注意要md5加密,同样不使用常量类
        employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));

        //设置当前记录的创建时间和修改时间
        employee.setCreateTime(LocalDateTime.now());
        employee.setUpdateTime(LocalDateTime.now());

        //设置当前记录创建人id和修改人id
        //TODO 后期需要改为当前登录用户的id
        employee.setCreateUser(10L);
        employee.setUpdateUser(10L);

        //插入员工数据
        employeeMapper.insert(employee);
    }
```

主要的操作就是设置真正存数据的实体类的域，其中要注意密码的md5处理和硬编码问题。最后的负责和数据库进行交互的实际起作用的是mapper类。

> 在 Java 的分层架构中，尤其是使用 Spring 框架时，**Mapper** 是一个非常重要的组成部分，通常用于数据访问层。
>
> - **Controller**：处理用户请求，调用 **Service** 进行业务逻辑处理。
> - **Service**：封装业务逻辑，调用 **Mapper** 执行具体的数据访问操作。
> - **Mapper**：执行 SQL 查询或操作，并返回结果给 Service 层。

真正的SQL语句传递者也是mapper：

```java
	/**
     * 插入员工数据
     * 驼峰命名已经在application.yml里开启了，会自动转换
     * @param employee
     */
    @Insert("insert into employee(name,username,password,phone,sex,id_number,create_time,update_time,create_user,update_user)"+
            "values"+
            "(#{name},#{username},#{password},#{phone},#{sex},#{idNumber},#{createTime},#{updateTime},#{createUser},#{updateUser})")
    void insert(Employee employee);
```

至此功能开发完毕，可以开始进行测试。

#### 功能测试

有两种测试方式：

- 通过接口文档测试（以这个为主）

  运行项目，打开接口文档

  ![image-20241130083756432](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411300838547.png)

  从侧边栏中进入新增员工内容页，开始进行调试：

  ![image-20241130084453717](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411300844783.png)

  直接发送JSON数据收不到响应，而是返回一个401.检查代码可以发现，这是因为代码中有个intercepter拦截器，会进行jwt令牌校验。

  ![](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411300848017.png)

  可以看到token为null（这是在请求头中配置的，名称为token是因为在yml配置文件中配置了），导致验证不能通过，会返回一个状态码401。正常来说是要登录后才会生成一个token返回给你，逻辑上来说就是需要登录之后才能做各种操作。测试的时候可以结合登录的功能来测试。先要获取到一个token，再把这个token拿来用。

  

  ![image-20241130090026537](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411300900604.png)

  ![](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411300903590.png)

- 通过前后端联调测试

  在前端页面里新增员工，也测试成功。

#### 代码完善

存在的问题：

- 录入的用户名已存在，抛出异常后没有处理

  ![image-20241130095304814](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411300953891.png)

  使用已有的全局异常处理器来捕获异常。

  ```java
  /**
       *
       * 处理SQL异常
       * @param ex
       * @return
       */
      @ExceptionHandler
      public Result exceptionHandler(SQLIntegrityConstraintViolationException ex){
          //Duplicate entry 'yaoguo' for key 'employee.idx_username'
          String message = ex.getMessage();
          if(message.contains("Duplicate entry")){
              String[] split=message.split(" ");
              String username=split[2];
              String msg=username+ MessageConstant.ALREADY_EXIST;
              return Result.error(msg);
          }else{
              return Result.error(MessageConstant.UNKNOWN_ERROR);
          }
      }
  ```

  修改完成后状态信息也会由原来的500：

  ![image-20241130100208201](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411301002260.png)

  变为OK的200，并提示具体的信息：

  ![image-20241130100237830](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411301002890.png)

- 新增员工时，创建人id和修改人id设置为了固定值

  要完成这个修改，首先要清楚jwt令牌验证的流程：

  ![image-20241130101408792](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411301014859.png)

  很明显具体的操作需要在拦截器处完成。JWT令牌在生成的时候就会把ID也包装进来：

  ![image-20241130102426766](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411301024832.png)

  empID同样也能被解包装并读取出来，问题就是：解析出登录员工id后如何传递给Service的save方法？

  ![image-20241130102605220](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411301026292.png)

  这需要用到新的知识：`ThreadLocal`

  > `ThreadLocal` 是 Java 中用于处理线程局部变量的一个类。它允许你为每个线程单独存储变量，使得每个线程都可以拥有自己的值，而彼此之间不会互相影响（这就是线程隔离的效果）。只有在线程内才能获取到对应的值，线程外则不能访问。

  后端用的是Tomcat服务器，它在接收到每个请求的时候就会为其单独创建一个线程，这个线程上会执行多个功能模块的代码，比如service、拦截器intercepter等等，满足这个条件并且想让这几个模块之间能够进行变量的相互通信，那么就可以使用`ThreadLocal`。

  可以使用在拦截器、controller和service中分别添加`System.out.println("当前线程的id："+Thread.currentThread().getId());`语句，然后发一次请求看看三处的线程id情况。结果是三处的线程id均为同一个值，这说明一次请求对应一次线程，这些功能模块的代码都在一个线程中执行。发第二个请求，线程id会发生变化。

  ![image-20241130134452627](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411301344735.png)

  最好是将这些方法封装成一个工具类便于使用。创建一个`BaseContext`类：

  ![image-20241130134640148](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411301346210.png)

  一个`ThreadLocal`实例对应一个局部变量，若是有多个局部变量要存，就需要创建多个实例。

  现在拦截器处使用`BaseContext`的`set`方法把解包装的`empId`赋值给`BaseContext`的局部变量。然后在`service`中的`save`方法里使用`BaseContext`的`get`方法获取局部变量的值，再赋值给实体类的对应的值。

  ```java
  //interceptor中代码
  Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
  BaseContext.setCurrentId(empId);
  
  //service中代码
  employee.setCreateUser(BaseContext.getCurrentId());
  employee.setUpdateUser(BaseContext.getCurrentId());
  ```

  至此新增员工的功能开发完毕，需要把新版本的代码推送到远端仓库。可以直接在IDEA中完成。

---

### 员工分页查询

还是这一套流程，分一共四步走。

#### 需求分析和设计

首先还是看产品原型，了解具体的业务流程和规则。

![image-20241130140623187](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411301406298.png)

看到需要按员工姓名查询、显示记录总数，一个页面中所有数据的集合...这一步是反映了需要向后端接口传递的参数。

接下来是查看接口文档，同样可以看到请求的参数，额外能看到的是返回数据和方法类型。查询使用的是GET。

![image-20241130141944947](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411301419021.png)

和之前一样，这些请求参数不直接传给对应的实体类，而是传给一个对应接口的`EmployeePageQueryDTO`，DTO的存在从设计上看是为了将内部数据模型和外部接口分离（解耦合），使得类似于内部数据结构的变化不会影响到外部用户的接口；同时使用DTO也可以选择实体类的哪些属性可以暴露给客户端，一定程度上也能提高安全性。

`EmployeePageQueryDTO`

```java
@Data
public class EmployeePageQueryDTO implements Serializable {

    //员工姓名
    private String name;

    //页码
    private int page;

    //每页显示记录数
    private int pageSize;

}
```

![image-20241130142016479](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202411301420549.png)

可能一开始会对如何分页的数据结构不知所措，解决方案是这样的：data中包含total和records两部分，其中total记录的是记录总数信息，records记录的是页面所有属性的表头集合，因此用一个数组来存。

#### 代码开发

设计后端查询之后返回前端的对象类型为`Result<PageResult>`，`PageResult`封装的是分页查询结果：

```java
/**
 * 封装分页查询结果
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class PageResult implements Serializable {

    private long total; //总记录数

    private List records; //当前页数据集合

}
```

Result中的data域是一个泛型，可以存储`PageResult`这种复杂类型的数据。

接着还是先到controller中创建一个新方法`page`，这里方法的参数不用加`@RequestBody`注解了，因为这个注解主要用来**接收JSON或XML数据**：当客户端发送JSON或XML格式的数据时，可以使用`@RequestBody`将这些数据自动转换为Java对象。这里传的已经不是JSON了。

```java
/**
     * 员工分页查询
     * @param employeePageQueryDTO
     * @return
     */
    @GetMapping("page")
    @ApiOperation("员工分页查询")
    public Result<PageResult> page( EmployeePageQueryDTO employeePageQueryDTO) {
        //方便调试
        log.info("员工分页查询，参数为：{}", employeePageQueryDTO);
        PageResult pageResult=employeeService.pageQuery(employeePageQueryDTO);
        return Result.success(pageResult);
    }
```

接着在service中声明方法`pageQuery`，

```java
/**
* 分页查询
* @param employeePageQueryDTO
* @return
*/
PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO);
```

在对应的impl中编写方法，通过mybatis的pageHelper框架来辅助分页的编码，完成的是SQL语句字符串拼接的任务，动态地会追加limit关键字。（底层实现可以去看源码，这里先学实现）

正常需要先在IDEA中下载mybatisX插件，然后在sky-server中的resources文件夹下创建一个EmployeeMapper.xml文件，用于存放动态的SQL信息（这里不再用之前静态注解的方式）。

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.sky.mapper.EmployeeMapper">
    <select id="pageQuery" resultType="com.sky.entity.Employee">
        select *from employee
        <where>
            <if test="name !=null and name !=''">
                and name like concat('%',#{},'%')
            </if>
        </where>
        order by create_time desc
    </select>
</mapper>

```

最后再加工一下service的返回值：

```java
/**
     * 分页查询
     * @param employeePageQueryDTO
     * @return
     */
    public PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO) {
        //基于SQL的limit关键字实现分页查询，后面的数字是具体的参数
        // select * from employee limit 0,10

        //开始分页查询
        PageHelper.startPage(employeePageQueryDTO.getPage(),employeePageQueryDTO.getPageSize());
        Page<Employee>page=employeeMapper.pageQuery(employeePageQueryDTO);

        //加工成期望的返回结果
        long total=page.getTotal();
        List<Employee> records=page.getResult();
        PageResult pageResult=new PageResult(total,records);
        return pageResult;
    }
```

一次开发完成。

#### 功能测试

还是两种方式：**swagger接口文档测试**、**前后端联调**

先通过swagger来测试，必填数据项是page（想查询的页码）和pageSize（一页的数据条数）

![image-20241201082852366](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412010828506.png)

填入后填发送，发现又出现了401错误。这是因为之前填入的token失效了，查阅application.yml发现，这是因为jwt令牌的有效时间设置为了7200000ms，也就是两小时，再做一遍前面的操作即可。

成功返回前端。

![image-20241201085259883](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412010852971.png)

接下来做前后端联调测试（别忘了启动nginx服务器），发现大体是正常的，但是有个小瑕疵：时间数据没有按想象的格式显示。

![image-20241201085217150](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412010852232.png)

#### 代码完善

我们前面可以看到，返回前端的时间数据是用数组来存的。前端渲染之后就会出现这样一连串的情况。

有两种解决方案（也许不止）：

![image-20241201085632565](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412010856667.png)

第一种方法较简单，但是有多个数据处每个地方都要加比较繁琐。

在本项目里只要去加两个注释即可，是在实体类的字段那里：

![image-20241201092001085](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412010920159.png)

第二种方法适用于大规模的项目，只需要重写`WebMvcConfiguration`类中的方法`extendMessageConverters`即可。

```java
/**
     * 扩展Spring MVC框架的消息转化器
     * @param converters
     */
    protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
        log.info("扩展消息转换器...");
        //创建一个消息转换器对象
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        //需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据
        //这个对象转换器已经写好，放在sky-common的json包中，这里只需要实例化即可
        converter.setObjectMapper(new JacksonObjectMapper());
        //将自己的消息转换器加入容器中
        //converters.add(converter);
        //converters原先就含有消息转换器，因此需要设置索引来保证优先使用
        converters.add(0,converter);
    }
```



![image-20241201092143250](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412010921330.png)

> Spring MVC 不会主动扫描项目中的每一个日期数据。相反，它会根据请求的内容类型和消息转换器的配置，处理请求体中的数据。具体来说：
>
> - **输入请求**：当接收到请求时，Spring MVC 会使用匹配的消息转换器将请求体中的 JSON 数据转换为 Java 对象。在这个过程中，日期字段会被解析为 `Date` 或 `LocalDateTime` 类型，具体取决于你的配置。
> - **输出响应**：当需要返回响应时，Spring MVC 会使用相应的消息转换器将 Java 对象转换为 JSON 格式。在这个过程中，日期字段会被序列化为指定的格式。

![image-20241201091830094](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412010918178.png)

---

### 启用禁用员工账号

#### 需求分析与设计

需求分析较为简单，可以不用分析原型。但需要了解以下的业务规则：

![image-20241201100155728](C:/Users/Star/AppData/Roaming/Typora/typora-user-images/image-20241201100155728.png)

接着看接口文档，

![image-20241201101102263](C:/Users/Star/AppData/Roaming/Typora/typora-user-images/image-20241201101102263.png)

![image-20241201101117788](C:/Users/Star/AppData/Roaming/Typora/typora-user-images/image-20241201101117788.png)

![image-20241201101125674](C:/Users/Star/AppData/Roaming/Typora/typora-user-images/image-20241201101125674.png)

#### 代码开发

开发流程还是controller→service→serviceimpl→mapper→具体的mapper.xml

重复的流程不再赘述，只讲要注意的知识点。

controller里使用了`@PathVariable`注解，表明从地址获取参数：

```java
 /**
     * 启用禁用员工账号
     * @param status
     * @param id
     * @return
     */
    @PostMapping("/status/{status}")
    @ApiOperation("启用禁用员工账号")
    public Result enableOrDisable(@PathVariable("status") Integer status,Long id) {
        log.info("启用禁用员工账号:{} {}", status, id);
        employeeService.enableOrDisable(status,id);
        return Result.success();
    }
```

在impl里使用了实体类的builder：

```java
Employee employee = Employee.builder()
                .status(status)
                .id(id)
                .build();
```

又学到了一个快捷键：先写等号右边的表达式，然后在语句末尾输入`.var`，IDEA会帮你进行赋值操作（补全等号左边的赋值对象）。

效果等同于：

```java
Employee employee=new Employee();
employee.setStatus(status);
employee.setId(id);
```

这个mapper.xml中为了让这个update的SQL语句能够重用，写成了一个动态的语句：

```xml
<update id="update" parameterType="Employee">
        update employee
        <set>
            <if test="name!=null">name=#{name},</if>
            <if test="username!=null">username=#{username},</if>
            <if test="password!=null">password=#{password},</if>
            <if test="phone!=null">phone=#{phone},</if>
            <if test="sex!=null">sex=#{sex},</if>
            <if test="idNumber!=null">idNumber=#{idNumber},</if>
            <if test="updateTime!=null">updateTime=#{updateTime},</if>
            <if test="updateUser!=null">updateUser=#{updateUser},</if>
            <if test="status!=null">status=#{status},</if>
        </set>
        where id=#{id}
    </update>
```

最后的接口文档测试和前后端联调均成功。

---

### 编辑员工

#### 需求分析和设计

产品原型

![image-20241201193931299](C:/Users/Star/AppData/Roaming/Typora/typora-user-images/image-20241201193931299.png)

有一个回显的操作，然后再来修改，所以有**两个接口**，第一个是*根据id查询员工信息*，第二个是*编辑员工信息。*

**查询**

![image-20241201194145690](C:/Users/Star/AppData/Roaming/Typora/typora-user-images/image-20241201194145690.png)

**编辑**

![image-20241201194217251](C:/Users/Star/AppData/Roaming/Typora/typora-user-images/image-20241201194217251.png)

#### 代码开发

流程同前，需要注意`controller`中返回参数类型`Result`是泛型，而且由于请求是GET类型，因此要显式指定泛型参数。如果是PUT和POST等等，则可以不用指定。

需要注意这里使用实体类`employee`来接受数据，但是我们不想把密码暴露给用户，所以需要在impl中做一些处理：

```java
/**
     * 根据id查询员工信息
     * @param id
     * @return
     */
    public Employee getById(Long id) {
        //调用持久层来查询，但是会返回密码，这是我们所不想暴露给用户的
        Employee employee=employeeMapper.getById(id);
        //稍微处理一下密码，调用set方法即可
        employee.setPassword("****");
        return employee;
    }
```

> 为什么不用DTO来接受所有数据？
>
> 考虑到可能使用到所有数据（根据接口文档），不能使用DTO来接受数据，接受不全。

![image-20241201205924300](C:/Users/Star/AppData/Roaming/Typora/typora-user-images/image-20241201205924300.png)

需要注意这次的mapper不再使用xml文件来写SQL语句，而是直接使用SELECT注释。

```java
/**
     * 根据id查询员工信息
     * @param id
     * @return
     */
    @Select("select * from employee where id=#{id}")
    Employee getById(Long id);
```

接着开发编辑功能。

编辑功能使用到了之前的mapper.xml中的update语句和mapper中的update方法。不过要注意方法参数。

```java
/**
     * 编辑员工信息
     * @param employeeDTO
     */
    public void update(EmployeeDTO employeeDTO) {
        //前面的知识
        Employee employee = new Employee();
        BeanUtils.copyProperties(employeeDTO,employee);
        employee.setUpdateTime(LocalDateTime.now());
        employee.setUpdateUser(BaseContext.getCurrentId());

        //前面写好的方法起作用了，别急着高兴，注意下面这个方法传的是employee对象，需要进行属性拷贝
        employeeMapper.update(employee);
    }
```

#### 功能测试

接口文档测试和前后端联调测试均成功，但是前端修改员工数据会有限制，用户名只能是小写字母且不能识别符号、大写字母、以及汉字。这是前端的逻辑了，先暂且按下不表。

---

### 修改密码

首先还是看接口文档，一般自己开发很少说要走整套流程，可以简化一下。

![image-20241202090400953](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412020904164.png)

![image-20241202090415178](C:/Users/Star/AppData/Roaming/Typora/typora-user-images/image-20241202090415178.png)

![image-20241202090425551](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412020904642.png)

这里对应的是controller的参数前的注释。整理一下，对应关系是这样的：

| 功能               | 请求参数                                 | 参数前的注释                                     |
| ------------------ | ---------------------------------------- | ------------------------------------------------ |
| 员工登录           | Header 参数、Body 参数`application/json` | `@RequestBody EmployeeLoginDTO`                  |
| 新增员工           | Header 参数、Body 参数`application/json` | `@RequestBody EmployeeDTO employeeDTO`           |
| 根据id查询员工     | Path 参数                                | `@PathVariable Long id`                          |
| 编辑员工信息       | Header 参数、Body 参数`application/json` | `@RequestBody EmployeeDTO employeeDTO`           |
| 退出登录           | Header 参数、Body 参数`application/json` | 无参                                             |
| 启用、禁用员工账号 | Path 参数、Query 参数、Header 参数       | `@PathVariable("status") Integer status,Long id` |
| 员工分页查询       | Query 参数                               | `EmployeePageQueryDTO`                           |
| 修改密码           | Header 参数、Body 参数`application/json` |                                                  |

> 在接口文档中，请求参数可分为 Header、Body、Query 和 Path 四种类型，它们在请求中的含义和表现形式各不相同。下面分别解释这四种参数的含义及其在代码中的体现。
>
> ### 1. Header 参数
> **含义：** Header 参数是请求附加的元数据，通常用于身份验证、请求的内容类型、响应格式等。常见的 Header 包括 `Authorization`、`Content-Type` 等。
>
> **代码示例：**
> ```python
> import requests
> 
> url = "https://api.example.com/resource"
> headers = {
>     "Authorization": "Bearer your_token",
>     "Content-Type": "application/json"
> }
> 
> response = requests.get(url, headers=headers)
> ```
>
> ### 2. Body 参数
> **含义：** Body 参数通常用于传送数据，比如在 POST、PUT 请求中发送的数据。Body 可以是 JSON、XML 或表单数据等格式。
>
> **代码示例：**
> ```python
> import requests
> import json
> 
> url = "https://api.example.com/resource"
> data = {
>     "name": "example",
>     "value": 123
> }
> 
> response = requests.post(url, json=data)  # 使用 JSON 格式的 Body
> ```
>
> ### 3. Query 参数
> **含义：** Query 参数附加在 URL 之后，用于过滤、排序或分页等功能。它们通常以键值对的形式存在，比如 `?key=value&key2=value2`。
>
> **代码示例：**
> ```python
> import requests
> 
> url = "https://api.example.com/resource"
> params = {
>     "filter": "active",
>     "sort": "desc"
> }
> 
> response = requests.get(url, params=params)  # Query 参数自动拼接到 URL 中
> ```
>
> ### 4. Path 参数
> **含义：** Path 参数是 URL 路径的一部分，通常用于指示资源的唯一标识符，比如 RESTful API 中的资源 ID。
>
> **代码示例：**
> ```python
> import requests
> 
> resource_id = 123
> url = f"https://api.example.com/resource/{resource_id}"  # Path 参数直接嵌入 URL
> 
> response = requests.get(url)
> ```
>
> ### 小结
> - **Header**：用于附加信息，如身份验证和数据格式，体现为请求中的 Header 字段。
> - **Body**：用于发送数据，通常在 POST 或 PUT 请求中使用 JSON 或表单格式。
> - **Query**：用于 URL 中的参数传递，多用于数据过滤和分页，表示为 URL 中的查询字符串。
> - **Path**：表示资源的唯一标识符，嵌入在 URL 的路径中。
>

---

### 导入分类模块功能代码

分类相关功能和之前的员工相关接口的实现大体相同，可以自己来写一写。不再记录，都在代码里。

---

## Day 3

### 公共字段自动填充

#### 问题分析

![image-20241203133155384](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412031332538.png)

这些字段是员工表、分类表等等业务表的公共字段。对其进行赋值的操作如下：

![image-20241203133259091](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412031332205.png)

可以看到实现的操作是差不多的，这就形成了一个代码冗余的问题，相关的业务需求一旦有变动，所有这些分散在不同地方的代码都需要修改，这显然是非常不利于维护的。

#### 实现思路

 回忆一下，这四个字段的操作时机分为两种，对应的SQL操作一种是insert操作、一种是update操作。

> **学到的新知识AOP**
>
> 以下是一个基于电商平台的具体例子，帮助你理解AOP的应用。
>
> ### 业务场景：电商平台的订单处理
>
> 在一个电商平台中，当用户下单时，需要处理多个横切关注点，比如：
>
> 1. **日志记录**：记录每个订单的创建信息，方便后续审计和监控。
> 2. **安全检查**：确保用户的支付信息和个人数据是安全的。
> 3. **性能监控**：监测订单处理的时间，及时进行性能优化。
>
> ### 使用AOP的实现
>
> 假设我们有一个处理订单的服务类 `OrderService`：
>
> ```java
> public class OrderService {
>     public void createOrder(Order order) {
>         // 处理创建订单的逻辑
>         System.out.println("订单已创建: " + order);
>     }
> }
> ```
>
> **切面（Aspect）**：我们可以定义一个切面 `OrderAspect`，来处理日志记录、安全检查和性能监控。
>
> ```java
> @Aspect
> public class OrderAspect {
> 
>     // 前置通知：在createOrder方法执行前记录日志
>     @Before("execution(* OrderService.createOrder(..))")
>     public void logBefore(JoinPoint joinPoint) {
>         System.out.println("创建订单前的日志: " + joinPoint.getSignature().getName());
>     }
> 
>     // 环绕通知：监控createOrder方法的性能
>     @Around("execution(* OrderService.createOrder(..))")
>     public Object monitorPerformance(ProceedingJoinPoint pjp) throws Throwable {
>         long startTime = System.currentTimeMillis();
>         Object result = pjp.proceed(); // 执行原方法
>         long endTime = System.currentTimeMillis();
>         System.out.println("创建订单耗时: " + (endTime - startTime) + "毫秒");
>         return result;
>     }
> 
>     // 后置通知：如果有异常则进行安全检查
>     @AfterThrowing(pointcut = "execution(* OrderService.createOrder(..))", throwing = "ex")
>     public void handleException(Exception ex) {
>         System.out.println("订单创建异常: " + ex.getMessage());
>         // 进行安全处理
>     }
> }
> ```
>
> ### 整体流程
>
> 1. 用户调用 `createOrder` 方法。
> 2. AOP会自动插入前置通知，记录日志。
> 3. 进入环绕通知，开始性能监控，并调用 `createOrder` 方法的实际逻辑。
> 4. 方法执行完毕后，环绕通知结束性能监控，并记录耗时。
> 5. 如果方法抛出异常，后置通知会捕获到异常并进行安全检查。
>
> ### 总结
>
> 通过AOP，我们能够将日志、安全和性能监控的逻辑从主业务逻辑中分离出来，使代码更加清晰和易于维护。同时，当需要修改这些横切关注点时，只需在切面中进行调整，而无需修改业务逻辑代码。
>
> **SpringAOP的底层**就是通过**动态代理**来实现的。它和**反射**一起 是JavaSE最重要的思想。
>
> 

![image-20241203134333182](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412031343314.png)

这里的实现思路也是AOP，实现步骤如上

新增两个文件，一个是自定义注解，另一个是自定义切面类：

![image-20241203201331996](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412032013168.png)

#### 代码开发

自定义注解

```java
package com.sky.annotation;

import com.sky.enumeration.OperationType;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 自定义注解，用于表示某个方法需要进行功能字段的自动填充处理
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AutoFill {
    //数据库操作类型：UPDATE INSERT
    OperationType value();
}

```

自定义切面类

```java
package com.sky.aspect;

import com.sky.annotation.AutoFill;
import com.sky.constant.AutoFillConstant;
import com.sky.context.BaseContext;
import com.sky.enumeration.OperationType;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.Signature;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.time.LocalDateTime;
import java.time.LocalTime;

/**
 * 自定义切面，实现公共字段自动填充的处理逻辑
 */
@Aspect
@Component
@Slf4j
public class AutoFillAspect {

    /**
     * 切入点，需要满足两个条件。mapper包、且有AutoFill注解
     */
    @Pointcut("execution(* com.sky.mapper.*.*(..)) && @annotation(com.sky.annotation.AutoFill)")
    public void autoFillPointCut() {}

    /**
     * 自定义前置通知，为公共字段赋值
     */
    @Before("autoFillPointCut()")
    public void autoFill(JoinPoint joinPoint) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        log.info("开始进行公共字段的自动填充");

        //获取到当前被拦截的方法上的数据库操作类型
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();//方法签名对象
        AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class);//获取方法上的注解对象
        OperationType operationType = autoFill.value();//获得数据库操作类型

        //获取到当前被拦截的方法的参数--实体对象
        Object[] args = joinPoint.getArgs();//获取所有的参数
        if(args==null || args.length==0){//说明没有参数,后面的操作没有必要做
            return;
        }

        Object entity = args[0];

        //准备赋值的数据
        LocalDateTime now = LocalDateTime.now();
        Long currentId = BaseContext.getCurrentId();

        //根据当前不同的操作类型,为对应的属性赋值(反射机制)
        if(operationType==OperationType.INSERT){
            //为四个公共字段赋值,还是要注意字符串的硬编码问题
            Method setCreateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);
            Method setCreateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);
            Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
            Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);

            //通过反射为对象赋值
            setCreateTime.invoke(entity,now);
            setCreateUser.invoke(entity,currentId);
            setUpdateTime.invoke(entity,now);
            setUpdateUser.invoke(entity,currentId);
        }else if(operationType==OperationType.UPDATE){
            //为两个公共字段赋值
            Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
            Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);

            setUpdateTime.invoke(entity,now);
            setUpdateUser.invoke(entity,currentId);
        }
    }
}
```

这里使用到的常量类，也是为了避免字符的硬编码问题：

```java
package com.sky.constant;

/**
 * 公共字段自动填充相关常量
 */
public class AutoFillConstant {
    /**
     * 实体类中的方法名称
     */
    public static final String SET_CREATE_TIME = "setCreateTime";
    public static final String SET_UPDATE_TIME = "setUpdateTime";
    public static final String SET_CREATE_USER = "setCreateUser";
    public static final String SET_UPDATE_USER = "setUpdateUser";
}

```

功能测试与之前一样，一切功能正常，说明自动生成成功了。

---

### 新增菜品

#### 需求分析和设计

先看产品原型：

![image-20241203201856235](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412032018359.png)

一共涉及三个接口，一个就是**按照类型查询分类**（有一个菜品分类的下拉框），这个是之前已经实现的功能；另一个是**文件上传**（上传菜品图片）；最后一个是**新增菜品**。

#### 代码开发

**开发文件上传接口**

前端通过浏览器进行文件的上传，提交给后端服务；后端服务拿到后，上传到阿里云OSS的对象存储服务。

![image-20241203203624624](C:/Users/Star/AppData/Roaming/Typora/typora-user-images/image-20241203203624624.png)

![image-20241203203630836](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412032036959.png)

要用到阿里云的OSS，在配置文件里配置alioss的API，这里是显式地配置，也可以用环境变量。也有对应的工具类和配置类，分别是`AliOssProperties`和`AliOssUtil`。

简单记录一下成功的过程。

首先编写一个配置类OssConfiguration用于创建AliOssUtil：

```java
/**
 * 配置类，用于创建AliOssUtil对象
 */
@Configuration
@Slf4j
public class OssConfiguration {
    @Bean
    @ConditionalOnMissingBean
    public AliOssUtil aliOssUtil(AliOssProperties aliOssProperties){
        log.info("开始创建阿里云文件上传工具类对象：{}", aliOssProperties);
        return new AliOssUtil(aliOssProperties.getEndpoint(),
                aliOssProperties.getAccessKeyId(),
                aliOssProperties.getAccessKeySecret(),
                aliOssProperties.getBucketName());
    }
}
```

接着按照前面的思路继续编写commonController：

```java
/**
 * 通用接口
 */
@RestController
@RequestMapping("/admin/common")
@Api(tags="通用接口")
@Slf4j
public class CommonController {

    @Autowired
    private AliOssUtil aliOssUtil;

    /**
     * 文件上传
     * @param file
     * @return
     */
    @PostMapping("upload")
    public Result<String> upload(MultipartFile file) {
        log.info("文件上传：{}", file);
        try {
            //原始文件名
            String originalFilename = file.getOriginalFilename();
            //截取后缀名
            String extension=originalFilename.substring(originalFilename.lastIndexOf("."));
            String objectName = UUID.randomUUID().toString() + extension;
            String filePath = aliOssUtil.upload(file.getBytes(), objectName);
            return Result.success(filePath);
        } catch (IOException e) {
            log.error("文件上传失败：{}", e.getMessage());
        }
        return null;
    }
}

```

用到了UUID来命名图片，这是用来保证上传的图片名字都是唯一的，这样就不会出现新图片覆盖旧图片的情况。由于上传的文件不会全是.jpg格式的，所以要动态地提取文件的后缀，利用字符串拼接的方法来命名。

最后进行测试，发现会报这样的错误：

```cmd
2024-12-04 10:47:26.589  INFO 36632 --- [nio-8080-exec-1] c.sky.controller.admin.CommonController  : 文件上传：org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@1958e752
2024-12-04 10:47:38.011  WARN 36632 --- [nio-8080-exec-1] com.aliyun.oss                           : [Server]Unable to execute HTTP request: 返回结果无效，无法解析。
[ErrorCode]: InvalidResponse
[RequestId]: 674FC2A79F6B6035378DEECF
[HostId]: null
[ResponseError]:
<?xml version="1.0" encoding="UTF-8"?>
<Error>
  <Code>AccessDenied</Code>
  <Message>You have no right to access this object because of bucket acl.</Message>
  <RequestId>674FC2A79F6B6035378DEECF</RequestId>
  <HostId>dishimage1234.oss-cn-beijing.aliyuncs.com</HostId>
  <EC>0003-00000001</EC>
  <RecommendDoc>https://api.aliyun.com/troubleshoot?q=0003-00000001</RecommendDoc>
</Error>

Caught an OSSException, which means your request made it to OSS, but was rejected with an error response for some reason.
Error Message:返回结果无效，无法解析。
Error Code:InvalidResponse
Request ID:674FC2A79F6B6035378DEECF
Host ID:null
```

这是由于没有设置正确的ACL权限引起的（ACL 是 **Access Control List** 的缩写，翻译为“访问控制列表”），需要在阿里云里设置“公共读写”。

![屏幕截图 2024-12-04 105939](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412041100893.png)

最后在前后端联调或是postman中测试，图片能够成功上传。

![image-20241204105553421](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412041056768.png)

postman中的body部分要选择文件：

![image-20241204110528303](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412041105442.png)

接下去继续新增菜品业务的开发，大体逻辑和之前一样，但是涉及到了两个表，即dish表和dishFlavor表，因此需要注意事务的原子性。其中口味是用户可选的字段，如果提交，则要在新增的方法里进行操作。

```java
/**
     * 新增菜品（含口味）
     * @param dishDTO
     */
    @Transactional
    public void addWithFlavor(DishDTO dishDTO) {

        Dish dish = new Dish();
        BeanUtils.copyProperties(dishDTO,dish);
        //向菜品表插入1条数据
        dishMapper.insert(dish);

        //获取insert语句生成的主键值
        Long dishId = dish.getId();

        //向口味表插入n条数据(n可以为0，即可以没有口味备注)
        List<DishFlavor> flavors = dishDTO.getFlavors();
        if(flavors!=null && flavors.size()>0){
            flavors.forEach(dishFlavor -> {
                dishFlavor.setDishId(dishId);
            });

            dishFlavorMapper.insertBatch(flavors);
        }
    }
```

这里还有另外一个注意的点，那就是口味的`dishId`并不是用户提交的，而是数据库自增的一个字段，即只有在数据库执行INSERT操作之后才能获取到，这里我们要把这个字段赋值给`dishFlavor`对象。

这是最关键的实现，`id`是生成的字段，允许我们调用（用之后的`getId`方法来获取）

```xml
	<insert id="insert" useGeneratedKeys="true" keyProperty="id">
        insert into dish(name, category_id, price, image, description, create_time, update_time, create_user, update_user,status)
        values
            (#{name},#{categoryId},#{price},#{image},#{description},#{createTime},#{updateTime},#{createUser},#{updateUser},#{status})
    </insert>
```

另外一个新知识就是，这里的口味是用一个方法`insertBatch`来批量插入的，对应的xml文件是`DishFlavorMapper.xml`：

```xml
	<insert id="insertBatch">
        insert into dish_flavor(dish_id, name, value)values
            <foreach collection="dishFlavors" item="df" separator=",">
                (#{df.dishId},#{df.name},#{df.value})
            </foreach>
    </insert>
```

这里的参数名字`dishFlavors`一定要与接口中`insertBatch`的参数名是一样的，不然会报参数相关的错误。

---

### 菜品分页查询

和之前的分页查询类似，不过这里可以根据需要来输入菜品名称、菜品分类、菜品状态来进行查询。

查看接口文档，发现是GET请求，返回的Result需要封装很多数据，其中包括一个categoryName，这是唯一一个不去Dish表里查的数据。请求参数是Query参数，是直接拼接在URL里的。

注意一下这个的xml文件的查询语句的写法：

```xml
	<select id="pageQuery" resultType="com.sky.vo.DishVO">
        SELECT d.*,c.`name` category_name FROM dish d left outer JOIN category c on d.category_id=c.id
        <where>
            <if test="name!=null">
                and d.name like concat('%',#{name},'%')
            </if>
            <if test="categoryId!=null">
                and d.category_id =#{categoryId}
            </if>
            <if test="status!=null">
                and d.status=#{status}
            </if>
        </where>
        order by create_time asc
    </select>
```

另外一个注意点：由于包含前面提到的他表的属性`categoryName`，这个字段是不被包括在对应的entity实体类中的，因此需要一个VO来包含所有这些属性，返回前端的对象也应该是`DishVO`：

```java
/**
 * 菜品分页查询
 * @param dishPageQueryDTO
 * @return
 */
public PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO) {
    PageHelper.startPage(dishPageQueryDTO.getPage(),dishPageQueryDTO.getPageSize());
    Page<DishVO> page=dishMapper.pageQuery(dishPageQueryDTO);
    return new PageResult(page.getTotal(),page.getResult());
}
```

---

### 删除菜品

#### 需求分析和设计

首先要明确业务规则：

![image-20241204173615055](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412041736249.png)

根据第一条设计规则，只用设计一个删除接口，即批量删除；单次删除一个菜品只是一个特殊情况。

难点无非在于关联关系的出现，让我们不能再套用之前简单情况下的删除做法。

![image-20241204173902603](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412041739745.png)

#### 代码开发

```java
/**
 * 批量删除菜品
 * @param ids
 * @return
 */
@DeleteMapping
@ApiOperation("批量删除菜品")
public Result delete(String ids){
    log.info("批量删除菜品");
    return Result.success();
}
```

一开始的想法确实是使用String类型的参数来接收，这样我们需要做一些额外的处理字符串的逻辑。仔细考虑，这是与业务无关的部分，纯粹是批量删除这个需求对应的接口设计引出来的多余的部分。

好在学习到了一个来自Spring框架的解决方案，本质其实就是我们不再多写这部分处理字符串的逻辑，而是让Spring框架自动帮我们完成。

```java
/**
     * 批量删除菜品
     * @param ids
     * @return
     */
    @DeleteMapping
    @ApiOperation("批量删除菜品")
    public Result delete(@RequestParam List<Long> ids){
        log.info("批量删除菜品:{}",ids);
        dishService.deleteBatch(ids);
        return Result.success();
    }
```

接着编写最重要的serviceImpl：

```java
/**
     * 菜品批量删除
     * @param ids
     */
    @Transactional
    public void deleteBatch(List<Long> ids) {
        //（判断）如果当前存在起售中的菜品，则应不能删除
        for (Long id : ids) {
            Dish dish=dishMapper.getById(id);
            if(dish.getStatus()== StatusConstant.ENABLE){
                //当前菜品处于起售中，不能删除，应有反馈
                throw new DeletionNotAllowedException(MessageConstant.DISH_ON_SALE);
            }
        }

        //（判断）如果当前存在被套餐关联的菜品，则应不能删除
        List<Long> setMealIdsByDishIds = setMealDishMapper.getSetMealIdsByDishIds(ids);
        if (setMealIdsByDishIds!=null && setMealIdsByDishIds.size()>0){
            //当前菜品被套餐关联了，不能删除
            throw new DeletionNotAllowedException(MessageConstant.DISH_BE_RELATED_BY_SETMEAL);
        }

        //删除菜品数据
        for (Long id : ids) {
            dishMapper.deleteById(id);
            //（关联）如果菜品存在口味数据，则应一并删除
            dishFlavorMapper.deleteByDishId(id);
        }
    }
```

当一个方法被 `@Transactional` 注解修饰时，这个方法会在一个事务上下文中执行，确保数据库操作的一致性和可靠性。一般来说一个方法里设计多个数据库操作（增删改查）时需要用到此注解。

最后的删除可以优化：

```java
//根据菜品id集合批量删除菜品数据
//sql:delete from dish where id in {id1,id2,id3,id4}
dishMapper.deleteBatchByIds(ids);
//（关联）根据菜品id集合批量删除口味数据
//sql:delete from dish_flavor where dish_id in {id1,id2,id3,id4}
dishFlavorMapper.deleteBatchByDishIds(ids);
```

在对应的XML里使用foreach循环和in关键字：

```xml
<delete id="deleteBatchByIds">
    delete from dish where id in
    <foreach collection="ids" item="id" open="(" close=")" separator=",">
        #{id}
    </foreach>
</delete>
```

---

### 修改菜品

#### 需求分析和设计

修改菜品的产品原型类似新增菜品，只不过多了回显的逻辑以及多表查询两个难点，这两个问题前面已经解决了。回显对应的是查询；多表查询注意连接和业务逻辑。

---

## Day 4

CRUD的实战到了，完成套餐管理模块所有业务功能，包括：

- 新增套餐
- 套餐分页查询
- 删除套餐
- 修改套餐
- 起售停售套餐

要求：

1. 根据产品原型进行需求分析，分析出业务规则
2. 设计接口
3. 梳理表之间的关系（分类表、菜品表、套餐表、口味表、套餐菜品关系表）
4. 根据接口设计进行代码实现
5. 分别通过swagger接口文档和前后端联调进行功能测试

---

### 新增接口

实际在做这个接口的过程中还是发现自己前面的学习有很多漏洞的：

一是没有了解产品原型，这样不知道有具体几个接口需要实现；这里选择套餐菜品还有一个回显的逻辑，是通过![image-20241205163113804](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412051631948.png)这个接口实现的。也需要我们补全。（这个属于dish部分的接口了)

![image-20241205162253219](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412051623418.png)

二是对业务不熟悉，一开始没有分析出新增套餐（setmeal表）之后也要新增套餐菜品表（setmeal_dish表）的业务逻辑来，这会影响serviceImpl中的代码实现；另外涉及多个数据库操作的方法要注意添加事务注解，确保动作的原子性。

```java
/**
 * 新增套餐
 * @param setMealDTO
 */
@Transactional
public void addWithDish(SetmealDTO setMealDTO) {
    //在套餐表里加入数据
    Setmeal setMeal = new Setmeal();
    BeanUtils.copyProperties(setMealDTO, setMeal);
    setMealMapper.insert(setMeal);

    //获取生成的套餐id
    Long setMealId = setMeal.getId();

    List<SetmealDish> setMealDishList = setMealDTO.getSetmealDishes();

    //套餐id不是传入的数据，而是需要赋值的自增数据，对每个菜品都赋值套餐id
    setMealDishList.forEach(setMealDish -> {
        setMealDish.setSetmealId(setMealId);
    });

    //在套餐的菜品表中加入关联的数据
    setMealDishMapper.insertBatch(setMealDishList);
}
```

三是xml文件的操作还不够熟悉，比如如何利用标签写一个动态的自动拼接SQL的语句来实现批量操作？另外Insert之后id是自增的，我们需要获取这个值并赋值给关联的套餐菜品，我一开始没有注意这一点，`Setmeal` 对象调用 `getId()` 方法后返回 `null`，这通常是因为在执行插入操作时没有正确获取 auto-generated key（自增主键）并赋值给 `setMeal` 对象。

```xml
<insert id="insert" useGeneratedKeys="true" keyProperty="id">
    insert into setmeal(category_id, name, price, status,<if test="description != null">description,</if>image, create_time, update_time, create_user, update_user)
    VALUES
    (#{categoryId}, #{name}, #{price}, #{status},<if test="description != null">#{description},</if>#{image}, #{createTime}, #{updateTime}, #{createUser}, #{updateUser})
</insert>
```

四是没有注意添加AutoFill注解，导致数据库中createTime等字段是null，这个注解应该添加到对应的mapper的方法前面。

```java
/**
 * 修改套餐信息
 * @param setmeal
 */
@AutoFill(value=OperationType.INSERT)
void update(Setmeal setmeal);
```

以上的问题都是在测试里发现的，可以发现测试和返工是多么的重要，这占据了大部分开发的时间，能一次过的情况还是很少很少的。

---

## Day 5

### Redis入门

#### Redis简介

Redis是一个基于**内存**的**key-value**结构数据库。MySQL是基于磁盘的，存的是文件，形式是二维表。

- 基于内存存储，读写性能更高（但是内存是有限的）。
- 适合存储热点数据（热点商品、咨询、新闻），短时间访问快、频次高，更新也快。
- 由于是基于内存的，它很像计算机里的缓存，缓存cache虽然性能更强，但是是不能代替磁盘的功能的，类比地说来，Redis只是作为MySQL的一个补充，还是不能代替MySQL的功能的。

> 补充知识：
>
> 1. **数据结构**：除了简单的键值对，Redis 还支持多种数据结构，包括字符串、哈希、列表、集合、有序集合、位图、超日志、地理空间索引等。
> 2. **高性能**：Redis 通过在内存中进行操作，可以实现每秒数十万次的读写请求，适合高并发的场景。
> 3. **持久化**：可以将数据持久化到磁盘，防止数据丢失。支持两种持久化方式：RDB 快照和 AOF （Append-Only File）日志。
> 4. **主从复制**：支持主从复制，允许数据在多个实例之间同步，用于提高可用性和读性能。
> 5. **分布式**：通过 Redis Cluster，可以实现水平扩展，处理更大的数据集。
> 6. **事务**：支持事务操作，可以通过 MULTI、EXEC、WATCH 命令实现。
> 7. **Lua 脚本**：支持在服务器端执行 Lua 脚本，使得复杂的操作可以原子性执行。
> 8. **事件驱动**：可以作为消息系统，通过发布/订阅机制处理消息传递。

#### Redis服务进程的启动和交互命令行的启动

Redis服务进程的启动和交互命令行的启动分别通过文件夹中的`redis-server.exe`和`redis-cli.exe`两个可执行文件完成，这两个组件常常是**同时启动**的。

未配置环境变量的情况下，进入到Redis的文件夹下打开cmd，使用下面的命令启动Redis的服务进程。代表的是按照配置文件中的配置启动服务器。

```cmd
D:\Redis\Redis-x64-5.0.14.1>redis-server.exe redis.windows.conf
```

![image-20241212133846377](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412121338514.png)

这个服务进程可以使用`Ctrl+C`快捷键来退出 。

接着不要关闭该窗口，继续启动服务的命令行客户端：

```cmd
D:\Redis\Redis-x64-5.0.14.1>redis-cli.exe
```

启动之后就可以输入各种命令了！比如使用`keys`命令来查看当前数据库中的所有键，使用`exit`来退出。

![image-20241212133710879](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412121337072.png)

另外Redis**没有用户的概念**且**默认不需要密码**，需要在配置文件中设置。

设置conf文件中的requirepass字段就可以设置密码了，然后在启动redis-cli.exe的时候使用-a参数加上自己的密码即可。注意配置文件在去掉注释之后语句前面不能有空格，否则会出错。

---

### Redis数据类型

Redis的key都是String类型的，而value的类型共有五种：

- 字符串`string`

  普通字符串, *Redis*中最简单的数据类型

- 哈希`hash`

  也叫散列,\类似于Java中的HashMap结构

- 列表`list`

  按照插入顺序排序, 可以有重复元素, 类似于Java中的LinkedList

- 集合`set`

  无序集合, 没有重复元素, 类似于Java中的HashSet

- 有序集合`sorted set /zset`

  集合中每个元素一个分数(score), 根据分数升序排序, 没有重复元素。

![image-20241212140517019](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412121405153.png)

---

### Redis常用命令

#### 字符串操作命令

- `SET key value` 设置指定key的值
- `GET key` 获取指定key的值
- `SETEX key seconds value` 设置指定key的值，并设置key的过期时间为seconds秒，常用于**验证码**
- `SETEX key value` 只有在key不存在时设置key的值

#### 哈希操作命令

其实哈希表存的值就是又一个哈希表。

- `HSET key field value `将哈希表key中的字段field的值设为value
- `HGET key field` 获取存储在哈希表中指定字段的值
- `HDEL key field` 删除存储在哈希表中的指定字段
- `HKEYS key` 获取哈希表中所有字段
- `HVALS key` 获取哈希表中所有值

![image-20241212144950764](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412121449857.png)

#### 列表操作命令

Redis列表是简单的字符串列表，按照插入顺序排序，常用命令：

- `LPUSH key value1 [value2]` 将一个或多个值插入到列表头部
- `LRANGE key start stop` 获取列表指定范围内的元素
- `RPOP key` 移除并获取列表最后一个元素（最右边的）
- `LPOP key` 移除并获取列表第一个元素（最左边的）
- `LLEN key` 获取列表长度

```cmd
> LPUSH myList NiKo Monesy Hunter Hooxi JKS
(integer) 5

> LRANGE myList 1 4
1) "Hooxi"
2) "Hunter"
3) "Monesy"
4) "NiKo"

> LRANGE myList 0 5
1) "JKS"
2) "Hooxi"
3) "Hunter"
4) "Monesy"
5) "NiKo"

```

发现是和栈差不多的先进后出的机制，序号也是反着排列的，越晚插入的序号越小。

注意到序号也是从0开始的。

#### 集合操作命令

Redis 中的集合是string类型的无序集合。集合成员是唯一的，集合中不能出现重复数据。

- `SADD key member1 [member2]` 向集合添加一个或多个成员
- `SMEMBER key` 返回集合中的所有成员
- `SCARD key` 获取集合的成员数
- `SINTER key1 [key2]` 返回给定的所有集合的交集
- `SUNION key1 [key2]` 返回所有给定集合的并集
- `SREM key member1 [member2]` 删除集合中一个或多个成员

#### 有序集合操作命令

Redis有序集合是string类型元素的集合，且不允许有重复成员。每个元素都会关联一个double类型的分数。

![image-20241212161621329](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412121616448.png)

- `ZADD key score1 member1 [score2 member2]` 向有序集合添加一个或多个成员
- `ZRANGE key start stop [WITHSCORES]` 通过索引区间返回有序集合中指定区间内的成员
- `ZINCRBY key increment member`有序集合中对指定成员的分数加上增量increment
- `ZREM key member1 [member2]` 移除有序集合中的一个或多个成员

```cmd
> ZADD myZSet 10.0 a 11.5 b 13.4 c 15.6 d
(integer) 4

> ZRANGE myZset 0 3
(empty list or set)

> ZRANGE myZSet 0 3
1) "a"
2) "b"
3) "c"
4) "d"

> ZRANGE myZSet 0 -1
1) "a"
2) "b"
3) "c"
4) "d"

> ZRANGE myZSet 0 -1 WITHSCORES
1) "a"
2) "10"
3) "b"
4) "11.5"
5) "c"
6) "13.4"
7) "d"
8) "15.6"

```

这里就发现key的值是区分大小写的。

#### 通用命令

通用命令是不分数据类型的，都可以使用的命令。

- `KEYS [pattern]` 查找所有符合给定pattern的key,这里也可以用`*`代表匹配所有类型的key
- `EXISTS key` 检查给定key是否存在
- `TYPE key` 返回key所储存的值的类型
- `DEL key [key2]` 该命令用于在key存在时删除key ，也可以批量删除


---

### 在Java中操作Redis

#### Redis的Java客户端

常用的有

- Jedis

- Lettuce

- Spring Data Redis（适合Spring项目）

  ![image-20241212163456184](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412121634272.png)

#### Spring Data Redis使用方式

![image-20241212163533137](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412121635233.png)

在pom.xml中导入对应依赖后，开始操作配置文件，配置数据库的用户名密码等信息。

接着创建`RedisConfiguration`配置类，在配置类中创建`RedisTemplate`对象：

```java
@Configuration
@Slf4j
public class RedisConfiguration {

    @Bean
    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory){
        log.info("开始创建redis模版对象...");
        RedisTemplate redisTemplate = new RedisTemplate();
        //设置Redis的连接工厂对象
        redisTemplate.setConnectionFactory(redisConnectionFactory);

        //设置Redis中key的序列化器
        redisTemplate.setKeySerializer(new StringRedisSerializer());

        // 设置value的序列化器
        redisTemplate.setValueSerializer(new StringRedisSerializer());

        return redisTemplate;
    }
}
```

这里设置的序列化器是为了避免存入数据时在图形界面中key和value的显示会乱码。

接着使用JUnit来进行测试，编写一个测试类`SpringDataRedisTest`，先测试一下redisTemplate能不能成功注入：

别忘了测试类的注解。这个注解只在需要测试的时候使用，平时开发就把这个代码注释了，避免每次运行都会加载整个应用上下文，这可能比较耗时。

```java
@SpringBootTest
public class SpringDataRedisTest {

    @Autowired
    private RedisTemplate redisTemplate;

    @Test
    public void testRedisTemplate() {
        System.out.println(redisTemplate);

        ValueOperations valueOperations = redisTemplate.opsForValue();
        HashOperations hashOperations = redisTemplate.opsForHash();
        ListOperations listOperations = redisTemplate.opsForList();
        SetOperations setOperations = redisTemplate.opsForSet();
        ZSetOperations zSetOperations = redisTemplate.opsForZSet();
    }

    @Test
    public void testStringOperations() {
        
    }
    
    @Test
    public void testHashOperations() {
        
    }
    
}
```

接下来先测试字符串类型数据的操作。

```java
@Test
    public void testStringOperations() {
        //共测试四个命令：set，get，setex，setnx

        //set(key,value)
        redisTemplate.opsForValue().set("key", "value");

        // get(key)
        String value = (String) redisTemplate.opsForValue().get("key");
        System.out.println(value); // 应该输出 "value"

        //setex(key,value,minutes/seconds,10)
        redisTemplate.opsForValue().set("key2", "value2",15, TimeUnit.SECONDS);

        //setnx(key,value)
        redisTemplate.opsForValue().setIfAbsent("key3", "value3");
    }
```

这里的`set`、`setnx`和`setex`命令在Java中都是通过`set`方法来完成的。

![image-20241216093249422](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412160932601.png)

这里的`TimeUnit`注解是用于选择计时单位的：

![image-20241216090817858](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412160931550.png)

接着测试哈希类型的命令：

```java
/**
 * 操作哈希类型的数据
 */
@Test
public void testHashOperations() {
    //hset，hget，hdel，hkeys，hvals
    HashOperations hashOperations = redisTemplate.opsForHash();

    hashOperations.put("myHash", "key1", "value1");
    hashOperations.put("myHash", "key2", "value2");

    hashOperations.get("myHash", "key1");

    hashOperations.keys("myHash");
    Set<String> keys = hashOperations.keys("myHash");
    System.out.println(keys);

    hashOperations.values("myHash");
    List<String> values = hashOperations.values("myHash");
    System.out.println(values);

    hashOperations.delete("myHash", "key1");
}
```

别忘了在配置类中加上两句语句来配置对应的序列化器：

```java
//设置哈希类型的序列化器
redisTemplate.setHashKeySerializer(new StringRedisSerializer());
redisTemplate.setHashValueSerializer(new StringRedisSerializer());
```

剩下的测试略，大致流程和这两个相类似。

```java
/**
 * 操作List类型的数据
 */
@Test
public void testListOperations() {
    //lpush，lrange，rpop，llen
    ListOperations listOperations = redisTemplate.opsForList();
    listOperations.leftPushAll("myList","a","b","c");
    listOperations.leftPush("myList", "d");

    List myList=listOperations.range("myList", 0, -1);
    System.out.println(myList);

    listOperations.rightPop("myList");
    listOperations.leftPop("myList");

    Long size=listOperations.size("myList");
    System.out.println(size);
}

/**
 * 操作集合类型的数据
 */
@Test
public void testSetOperations() {
    //sadd,smembers,scard,sunion,sinter,srem
    SetOperations setOperations = redisTemplate.opsForSet();

    setOperations.add("set1",  "a", "b", "c", "d");
    setOperations.add(  "set2", "a", "b", "x", "y");

    Set members = setOperations.members(  "set1");
    System.out.println(members);

    Long size = setOperations.size(  "set1");
    System.out.println(size);

    Set intersect = setOperations.intersect("set1", "set2");
    System.out.println(intersect);

    Set union = setOperations.union(  "set1",  "set2");
    System.out.println(union);

    setOperations.remove(  "set1",  "a", "b");
}

/**
 * 操作有序集合类型的数据
 */
@Test
public void testZSetOperations() {
    //zadd,zrange,zincreby,zrem
    ZSetOperations zSetOperations = redisTemplate.opsForZSet();

    zSetOperations.add("zset1",  "a",  10);
    zSetOperations.add("zset1",  "b",  12);
    zSetOperations.add("zset1",  "c",  9);

    Set zset1 = zSetOperations.range("zset1", 0, -1);
    System.out.println(zset1);

    zSetOperations.incrementScore("zset1",  "c", 10);
    zSetOperations.remove("zset1",  "a", "b");

}

/**
 * 测试通用命令
 */
@Test
public void testCommonOperations(){
    //keys exists type del
    Set keys = redisTemplate.keys( "");
    System.out.println(keys);

    Boolean name = redisTemplate.hasKey("name");
    Boolean set1 = redisTemplate.hasKey("set1");

    for (Object key : keys) {
        DataType type = redisTemplate.type(key);
        System.out.println(type.name());
    }

    redisTemplate.delete("mylist");
}
```

---

### 店铺营业状态设置

业务功能分析：

![image-20241216103234345](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412161032552.png)

接口设计：

![image-20241216103315519](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412161033822.png)

一共两个接口，需要能够修改营业状态并且需要获取营业状态在前端进行回显。

设计两个controller分别是user包中的`ShopController`和admin包中的`ShopController`，因为名称相同，所以需要指定一下Bean的名称，（此风格bean小写开头），

```java
package com.sky.controller.admin;

@RestController("adminShopController")
@RequestMapping("/admin/shop")
@Api(tags="店铺相关接口")
@Slf4j
public class ShopController {

    @Autowired
    private RedisTemplate redisTemplate;

    /**
     * 设置店铺营业状态
     * @return
     */
    @PutMapping("/{status}")
    @ApiOperation("设置店铺营业状态")
    public Result setStatus(@PathVariable Integer status){
        log.info("设置店铺营业状态:{}",status==1? MessageConstant.SHOP_OPENING :MessageConstant.SHOP_CLOSED);
        redisTemplate.opsForValue().set(RedisConstant.SHOP_STATUS,String.valueOf(status));
        return Result.success();
    }

    /**
     * 获取店铺营业状态
     * @return
     */
    @GetMapping("/status")
    @ApiOperation("获取店铺营业状态")
    public Result<Integer> getStatus(){
        String statusString = (String) redisTemplate.opsForValue().get(RedisConstant.SHOP_STATUS);
        Integer status = statusString != null ? Integer.valueOf(statusString) : null; // 处理可能的空值
        log.info("获取店铺营业状态:{}",status==1? MessageConstant.SHOP_OPENING :MessageConstant.SHOP_CLOSED);
        return Result.success(status);
    }
}
```

```java
package com.sky.controller.user;

@RestController("userShopController")
@RequestMapping("/user/shop")
@Api(tags="店铺相关接口")
@Slf4j
public class ShopController {

    @Autowired
    private RedisTemplate redisTemplate;

    /**
     * 获取店铺营业状态
     * @return
     */
    @GetMapping("/status")
    @ApiOperation("获取店铺营业状态")
    public Result<Integer> getStatus(){
        String statusString = (String) redisTemplate.opsForValue().get(RedisConstant.SHOP_STATUS);
        Integer status = statusString != null ? Integer.valueOf(statusString) : null; // 处理可能的空值
        log.info("获取店铺营业状态:{}",status==1? MessageConstant.SHOP_OPENING :MessageConstant.SHOP_CLOSED);
        return Result.success(status);
    }
}

```

要注意字符串的硬编码问题和使用Redis的时机与方法。另外就是不是所有的地方都无脑使用类型强制转换就可以的。

> ### **1. 强制转换的基本原则**
>
> - 父类与子类之间的转换
>
>   ：
>
>   - 在Java中，子类对象可以被强制转换为父类类型（向上转型），这是安全的。
>   - 但是，当你尝试将父类对象转换为子类类型（向下转型）时，只有当这个对象本身确实是子类的实例时，转换才是安全的。否则，将抛出 `ClassCastException`。
>
> 示例：
>
> ```
> javaclass Animal {}  
> class Dog extends Animal {}  
> 
> Animal animal = new Dog(); // 向上转型，安全  
> Dog dog = (Dog) animal; // 向下转型，安全  
> ```
>
> 如果是：
>
> ```
> javaAnimal animal = new Animal();   
> Dog dog = (Dog) animal; // 会抛出 ClassCastException  
> ```
>
> ### **2. 强制转换时的类型检查**
>
> 在进行强制转换之前，使用 `instanceof` 关键字，检查对象的实际类型，以避免 `ClassCastException`。
>
> 示例：
>
> ```
> javaif (animal instanceof Dog) {  
>     Dog dog = (Dog) animal; // 安全  
> }  
> ```
>
> ### **3. 集合与类型转换**
>
> 对于集合和对象类型，使用强制转换时要特别小心。在使用泛型时，编译器会进行类型检查：
>
> - 对于 `List<Object>` 中的元素，如果你试图将其转换为 `String`，而这个 `List` 实际上存储的是 `Integer`，将会抛出 `ClassCastException`。
>
> ### **4. 数据存储与取回**
>
> 当涉及到从储存（如数据库或Redis）中取出对象时，确保你知道存储的数据类型。Java的型别是静态的，而某些储存系统在时存储时不保留类型信息。
>
> - 例如，如果你将一个 `Integer` 以 `String` 的形式 存入 Redis（如 `String.valueOf(integer)`），在取出时必须使用 `String` 类型处理。
>
> ### **总结**
>
> #### **何时可以使用强制转换**：
>
> - 当你明确知道对象的实际类型，并且这种转换是安全的（如父类到子类，且父类对象实际是子类实例）。
> - 当你在使用集合或泛型时，确保集合中存放的是你将要转换的类型。
>
> #### **何时不能使用强制转换**：
>
> - 当你不确定对象的实际类型，或者当对象的实际类型与目标类型不一致时，直接的强制转换将导致 `ClassCastException`。
>
> ### **避免问题的最佳实践**
>
> 1. **使用`instanceof`检查**：始终在进行向下转型之前，检查对象的实际类型。
> 2. **统一存储与访问类型**：从存储中获取数据时，确保你明确知道数据的类型，并进行相应的处理。
> 3. **使用泛型**：在可能的情况下使用泛型，它可以在编译时提供类型安全。
>
> 通过这些原则和最佳实践，你可以在开发中更有效地管理和使用类型强制转换，减少运行时的错误。

---

## Day 6

主要学习**`HttpClient`**和**微信小程序**的开发。

### HttpClient

这是一个Apache Jakarta Common下的子项目，是一个支持HTTP协议的客户端编程工具包，允许我们在Java环境中构造并发送HTTP请求。

在使用之前，肯定需要先导入对应的工具包：

![image-20241216133949344](C:/Users/Star/AppData/Roaming/Typora/typora-user-images/image-20241216133949344.png)

核心API包括：

- `HttpClient`
- `HttpClients`
- `CloseableHttpClient`
- `HttpGet`
- `HttpPost`

阿里云的OSS依赖中其实已经用到了`HttpClient`，通过依赖传递的功能，已经导入，这里就不用再次显式地引入一遍了。

![image-20241216135115633](C:/Users/Star/AppData/Roaming/Typora/typora-user-images/image-20241216135115633.png)

接下来编写一个单元测试类来测试`HttpClient`的两种请求的发送。

先测试GET请求，按照发送请求的步骤来编写代码：

![image-20241216134736558](C:/Users/Star/AppData/Roaming/Typora/typora-user-images/image-20241216134736558.png)

```java
/**
 * 测试通过httpclient发送GET方式的请求
 */
@Test
public void testGET()throws Exception{
    // 创建HttpClient
    CloseableHttpClient httpClient = HttpClients.createDefault();

    // 创建请求
    HttpGet httpGet = new HttpGet("http://localhost:8080/user/shop/status");

    // 执行请求，获取响应
    CloseableHttpResponse response = httpClient.execute(httpGet);

    // 获取响应状态码
    int statusCode = response.getStatusLine().getStatusCode();
    System.out.println("服务器返回的状态码为： " + statusCode);

    HttpEntity entity = response.getEntity();
    String body = EntityUtils.toString(entity);
    System.out.println("服务器返回的内容为： " + body);

    // 释放资源
    response.close();
    httpClient.close();

}
```

接着测试POST请求，我们知道POST方法是有一个JSON格式的参数的，所以这里要封装到请求对象的`entity`中去。剩下的步骤和GET请求测试的步骤相同，不再赘述。

```java
/**
 * 测试通过httpclient发送POST方式的请求
 */
@Test
public void testPOST() throws IOException {
    //创建HttpClient对象
    CloseableHttpClient httpclient = HttpClients.createDefault();

    //创建http请求
    HttpPost httpPost = new HttpPost("http://localhost:8080/admin/employee/login");

    //POST请求要比GET请求多一步，封装请求参数
    JSONObject jsonObject = new JSONObject();
    jsonObject.put("username", "admin");
    jsonObject.put("password", "123456");

    StringEntity entity = new StringEntity(jsonObject.toString());
    entity.setContentType("application/json");
    entity.setContentEncoding("UTF-8");

    httpPost.setEntity(entity);

    //发送请求
    CloseableHttpResponse response = httpclient.execute(httpPost);

    //处理返回结果
    //获取响应状态码和响应内容
    Integer statusCode = response.getStatusLine().getStatusCode();
    System.out.println("服务器返回的状态码是:"+statusCode);

    HttpEntity responseEntity = response.getEntity();
    String content = EntityUtils.toString(responseEntity);
    System.out.println("服务器返回的内容是:"+content);

    //操作完毕后应该释放资源（先创建的后释放）
    response.close();
    httpclient.close();
}
```

这两个测试类的编写有助于我们在实际项目中编写自己的`HttpClientUtil`工具类，实际的思路是差不多的，也是定义两个方法分别对应GET和POST请求，不同的是我们需要在方法中设置一个paraMap用于存放参数，这样无论实际接口是否需要参数，我们都可以利用哈希表来处理。

```java
package com.sky.utils;

/**
 * Http工具类
 */
public class HttpClientUtil {

    static final  int TIMEOUT_MSEC = 5 * 1000;

    /**
     * 发送GET方式请求
     * @param url
     * @param paramMap
     * @return
     */
    public static String doGet(String url,Map<String,String> paramMap){
        // 创建Httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();

        String result = "";
        CloseableHttpResponse response = null;

        try{
            URIBuilder builder = new URIBuilder(url);
            if(paramMap != null){
                for (String key : paramMap.keySet()) {
                    builder.addParameter(key,paramMap.get(key));
                }
            }
            URI uri = builder.build();

            //创建GET请求
            HttpGet httpGet = new HttpGet(uri);

            //发送请求
            response = httpClient.execute(httpGet);

            //判断响应状态
            if(response.getStatusLine().getStatusCode() == 200){
                result = EntityUtils.toString(response.getEntity(),"UTF-8");
            }
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            try {
                response.close();
                httpClient.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        return result;
    }

    /**
     * 发送POST方式请求
     * @param url
     * @param paramMap
     * @return
     * @throws IOException
     */
    public static String doPost(String url, Map<String, String> paramMap) throws IOException {
        // 创建Httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();
        CloseableHttpResponse response = null;
        String resultString = "";

        try {
            // 创建Http Post请求
            HttpPost httpPost = new HttpPost(url);

            // 创建参数列表
            if (paramMap != null) {
                List<NameValuePair> paramList = new ArrayList();
                for (Map.Entry<String, String> param : paramMap.entrySet()) {
                    paramList.add(new BasicNameValuePair(param.getKey(), param.getValue()));
                }
                // 模拟表单
                UrlEncodedFormEntity entity = new UrlEncodedFormEntity(paramList);
                httpPost.setEntity(entity);
            }

            httpPost.setConfig(builderRequestConfig());

            // 执行http请求
            response = httpClient.execute(httpPost);

            resultString = EntityUtils.toString(response.getEntity(), "UTF-8");
        } catch (Exception e) {
            throw e;
        } finally {
            try {
                response.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        return resultString;
    }

    /**
     * 发送POST方式请求
     * @param url
     * @param paramMap
     * @return
     * @throws IOException
     */
    public static String doPost4Json(String url, Map<String, String> paramMap) throws IOException {
        // 创建Httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();
        CloseableHttpResponse response = null;
        String resultString = "";

        try {
            // 创建Http Post请求
            HttpPost httpPost = new HttpPost(url);

            if (paramMap != null) {
                //构造json格式数据
                JSONObject jsonObject = new JSONObject();
                for (Map.Entry<String, String> param : paramMap.entrySet()) {
                    jsonObject.put(param.getKey(),param.getValue());
                }
                StringEntity entity = new StringEntity(jsonObject.toString(),"utf-8");
                //设置请求编码
                entity.setContentEncoding("utf-8");
                //设置数据类型
                entity.setContentType("application/json");
                httpPost.setEntity(entity);
            }

            httpPost.setConfig(builderRequestConfig());

            // 执行http请求
            response = httpClient.execute(httpPost);

            resultString = EntityUtils.toString(response.getEntity(), "UTF-8");
        } catch (Exception e) {
            throw e;
        } finally {
            try {
                response.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        return resultString;
    }
    private static RequestConfig builderRequestConfig() {
        return RequestConfig.custom()
                .setConnectTimeout(TIMEOUT_MSEC)
                .setConnectionRequestTimeout(TIMEOUT_MSEC)
                .setSocketTimeout(TIMEOUT_MSEC).build();
    }

}
```

### 微信小程序开发

在官网先申请一个测试号，并保存对应的`AppID`和`AppSecret`，在后续的过程中要用到。

接下来需要使用微信官方的开发工具，[微信开发者工具下载 ](https://developers.weixin.qq.com/miniprogram/dev/devtools/stable.html)，按照引导安装即可。

安装完毕后打开，进入创建小程序的页面，这里要填之前的`AppID`：

![image-20241218163704374](C:/Users/Star/AppData/Roaming/Typora/typora-user-images/image-20241218163704374.png)

首先应该了解小程序的大致结构：

![image-20241218164600961](C:/Users/Star/AppData/Roaming/Typora/typora-user-images/image-20241218164600961.png)

可以看到逻辑基本属于前端逻辑，使用的是`javascript`。

其中一个页面由四个文件组成：`js + wxml + json+ wxss`其中的`wxml`其实就相当于`xml`，`wxss`其实就相当于`css`

![image-20241218164836422](C:/Users/Star/AppData/Roaming/Typora/typora-user-images/image-20241218164836422.png)

开发的步骤暂时省略，待之后学完前端来补全。

接下来考虑如何发布小程序：

首先开发完毕之后点击上传，就会从本地上传一个开发版本，可以从小程序的官网里看到。

![image-20241218171323628](C:/Users/Star/AppData/Roaming/Typora/typora-user-images/image-20241218171323628.png)

在官网页面可以审核开发版本，得到一个审核版本，审核版本通过之，经由*发布* 功能就可以成功上线了。

### 微信登录

这里开始又回到Java的主场，首先还是要修改配置文件，配置好小程序的`appid`和`appsecret`，便于后面使用`JwtPropertities`来读取。

先看接口文档，一看请求格式和路径：

![image-20241221141736064](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412211418191.png)

这说明是用户端的功能，且我们需要建立一个user开头的controller。

二看请求参数：

![image-20241221141850408](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412211418506.png)

请求参数是json格式的，因此要加`RequestBody`注解。

三看返回参数：

![image-20241221141906239](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412211419343.png)

返回参数也是JSON格式的，并且data部分要附加`id、openid、token`三个参数，因此再返回前要进行封装。

按照上面的思路，先创建一个`UserController`,别忘了加上`@Controller、@RequestMpping、@Slf4j`注解，涉及登录功能，要为用户生成jwt令牌，因此要调用`JwtUtils`工具类的`createJWT`方法，最后返回给前端的result对象的泛型是一个`UserLoginVO`。

```java
package com.sky.controller.user;

@RestController
@RequestMapping("/user/user")
@Api(tags="C端用户相关接口")
@Slf4j
public class UserController {
    @Autowired
    private UserService userService;

    @Autowired
    private JwtProperties jwtProperties;

    /**
     * 微信登录
     * @param userLoginDTO
     * @return
     */
    @PostMapping("/login")
    @ApiOperation("微信登录")
    public Result<UserLoginVO> login(@RequestBody UserLoginDTO userLoginDTO) {
        log.info("微信登录：{}",userLoginDTO);
        User user =userService.wxLogin(userLoginDTO);

        //为微信用户生成jwt令牌
        Map<String,Object> claims=new HashMap<>();
        //设置claim的主要目的是为了让不同ID用户所生成的token不一样
        claims.put(JwtClaimsConstant.USER_ID,user.getId());

        //需要三个参数：String secretKey, long ttlMillis, Map<String, Object> claims
        String token=JwtUtil.createJWT(jwtProperties.getUserSecretKey(), jwtProperties.getUserTtl(),claims);

        UserLoginVO userLoginVO = UserLoginVO.builder()
                .id(user.getId())
                .openid(user.getOpenid())
                .token(token)
                .build();

        return Result.success(userLoginVO);
    }
}
```

接着开发service中的方法。

```java
/**
 * 微信登录
 * @param userLoginDTO
 * @return
 */
User wxLogin(UserLoginDTO userLoginDTO);
```

别忘了在实现类中加入`@Service`标签，这个登录的逻辑要搞清楚，首先我们使用DTO来接受前端传来的数据（其实就只有一个code），接收到`code`之后我们通过`HttpClient`的功能访问微信官方的URL（调用微信的接口）来获取对应的openid。

注意！具体实现时，我们在调用`doGET`方法之前首先要给它完整的参数列表，这里用一个map来存，`doGET`方法返回的是一个JSON格式的数据，使用`fastjson`包的方法来解析，获取其中的叫`openid`的字段值。

接着获得`openid`之后去查询数据库是否存在该用户，查到就返回一个`User`；如果没查到（即`User`是`null`），那就需要我们自动完成用户注册（insert操作，新建数据库数据），最后再返回这个User对象就可以了。

```java
package com.sky.service.impl;

@Service
@Slf4j
public class UserServiceImpl implements UserService {

    //微信服务接口地址
    public static final String WX_LOGIN_URL = "https://api.weixin.qq.com/sns/jscode2session";

    @Autowired
    private WeChatProperties weChatProperties;

    @Autowired
    private UserMapper userMapper;

    /**
     * 微信登录
     * @param userLoginDTO
     * @return
     */
    public User wxLogin(UserLoginDTO userLoginDTO) {
        String openid = getOpenId(userLoginDTO.getCode());

        //判断openid是否为空,如果为空表示登录失败.抛出业务异常
        if(openid==null){
            throw new LoginFailedException(MessageConstant.LOGIN_FAILED);
        }

        //判断当前用户是否为新用户(没有查到),开始涉及mapper
        User user = userMapper.getUserByOpenId(openid);

        //如果是新用户,自动完成注册(构造新用户并存到数据库)
        if (user == null) {
            user = User.builder()
                    .openid(openid)
                    .createTime(LocalDateTime.now())
                    .build();
            userMapper.insert(user);
        }

        //返回这个用户对象
        return user;
    }

    /**
     * 调用微信接口服务,获得当前微信用户的openid(使用httpclient来发送请求)
     * @param code
     * @return
     */
    private String getOpenId(String code) {
        //调用微信接口服务,获得当前微信用户的openid(使用httpclient来发送请求)
        Map<String, String> params = new HashMap<>();
        params.put("appid",weChatProperties.getAppid());
        params.put("secret", weChatProperties.getSecret());
        params.put("js_code", code);
        params.put("grant_type","authorization_code" );
        String json = HttpClientUtil.doGet(WX_LOGIN_URL, params);

        //用fastjson工具来解析
        JSONObject jsonObject = JSONObject.parseObject(json);
        String openid = jsonObject.getString("openid");

        return openid;
    }
}
```

看下来`service`层涉及两个数据库操作，一个是根据`openid`查用户（select），另外一个是新增用户（insert），在`UserMapper`中编写对应的处理逻辑。为了展示写法，一个写在方法注释里，另一个写在xml文件里。

```java
/**
 * 根据openid查询用户
 * @param openid
 * @return
 */
@Select("select * from user where openid=#{openid}")
User getUserByOpenId(String openid);
```

```xml
<insert id="insert" useGeneratedKeys="true" keyProperty="id">
    insert into user(openid, name, phone, sex, id_number, avatar, create_time)
    values
        (#{openid},#{name},#{phone},#{sex},#{idNumber},#{avatar},#{createTime})
</insert>
```

---

## Day 7 

主要学习缓存和购物车功能。

缓存功能是为了应对多用户访问而高频度查表的场景，若是不加缓存功能，程序也能正常运行，但是由于数据库访问量大，访问压力大，会造成查询性能下降，直观的体验就是响应会变慢，用户的体验不好，页面加载会很慢。为了优化体验，实现项目的缓存功能，把页面数据缓存下来，是必要之举。一开始的想法是使用Redis来存储缓存数据，也就是说在第一次查表之后，就把MySQL表中的数据给缓存到Redis中去，这样下次再访问数据库，就把查表的请求给Redis，这样虽然也做了一次查询，但是由于Redis是基于内存的存储模式，所以速度就会快得多。留待学习之后的验证。

购物车逻辑比较简单，主要是添加、查看和清空三个功能。

### 缓存菜品

确实是通过Redis来缓存菜品数据，来减少数据库查询操作。要注意的是Redis的空间有限，因此需要定期更新。

![IMG_8779(20241222-113207)](C:/TencentMessage/QQ/1447444352/FileRecv/MobileFile/IMG_8779(20241222-113207).PNG)

这个存储的逻辑是非常类似计算机组成原理的Cache工作原理的，一次读取，后续直接使用。发散一下，这个思路也很类似今天八股刚学的JIT编译器机制。

> 1. **击穿**：指的是某个缓存数据失效，但恰好在这时大量请求同时来访问这个数据。因为缓存丢失，这些请求直接去访问数据库，可能导致数据库瞬间压力增大，甚至崩溃。
> 2. **穿透**：发生在请求访问一个根本不存在的缓存或数据时。比如，当用户请求一个不存在的ID时，系统会无差别地请求数据库，而这些请求就会“穿透”缓存，直接打到数据库上，导致数据库承受过多无效请求。
> 3. **雪崩**：是指当大量缓存同时失效时，所有请求都涌向数据库，这会造成数据库系统瞬间崩溃。比如，某个定时任务在同一时间失效，所有的用户请求都去访问这个密集的缓存，数据库自然抵挡不住。
>
> 概括来说：穿透->数据不在缓存也不再数据库,雪崩->大量缓存同时过期,击穿->热点数据过期

#### 实现思路

具体来说，小程序页面展示的粒度是 *菜品分类* 级别的，因此我们可以来**对每个分类的菜品保存一份缓存数据**。

- 这个方法的实现有一个难点，那就是一个分类下面有多个菜品，存储到Redis里应该采用什么数据结构来存？key的话只有字符串类型，用来存储分类的名称。另外value的一个方案就是采用字符串String类型，存分类中菜品数据集合所转化成的字符串。另一个方案是往hash中存，不过这个方案的粒度太细了，也就是说key里面存的就不是分类了，而是菜品了，否则存不完数据或者需要链接表，实现起来可能会比较繁琐。
- 因此我们可以来改造一下原有的查询逻辑，当前端给我们发送请求后，顺着这个请求的路径去改处理逻辑，在查表之前进行判断，如果缓存存在，就优先读取缓存；如果缓存不存在，则进行查表，在查表操作之后还需要将查到的数据写入缓存。
- 最后，存入数据之后我们还需要在菜品数据有变更的时候清理缓存数据，否则会出现数据不一致的情况。（暂时采用清空缓存的方法，虽然这并不是一个非常优雅的做法）

### 缓存套餐

#### 简单了解Spring cache

使用*Spring Cache*这个框架来实现redis的缓存功能，使用的方式类似之前使用的事务注解，在对应的方法前加上缓存注解即可。

Spring Cache提供了一层抽象，让我们可以切换不同的底层实现，比如EHCache、Caffeine、redis，非常灵活。使用哪个就导入对应的jar包，而代码不用做更改（注解都是一致的，不用改）。

![image-20241225143928816](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412251439012.png)

这里最后的`@CacheEvict`其实是用于在更新或删除数据时，清除缓存中的相关条目，表里说的不完善。如果是要批量删除，那就使用参数`allEntries=true`.

可以看到，之前的操作全部可以通过框架自动实现，而我们要做的只是用注解标记所需要进行缓存操作的位置即可。在注释里一般我们只需要关注`cacheNames`和`key`两个参数即可。

`@Cacheable`注解的底层实现其实也是**代理**，在访问具体对象前先访问代理对象，在代理对象中去查询redis，这样就会出现有缓存的情况下直接返回了查询结果，而不会真正执行对应的查表等方法。

综上，增删改查四个功能中：**增**对应的应该是`@CacheEvict`，分析业务逻辑可知，在新增套餐时，应该清理缓存，重新去查表，这样才能显示完整的套餐列表；**删**和**改**对应的也是`@CacheEvict`，这个没有疑问；**查**的时候才需要用`@Cacheable`，有则调缓存，无则存缓存。另外根据是否需要精确删除缓存数据来合理选择用`key`还是`allEntries`参数即可。

#### 实现缓存套餐功能

根据上面的提示添加，比较简单，就不赘述了，需要注意测试的时候把套餐起售了再测试。

### 添加购物车

还是从分析需求开始，请求方式是POST，

![image-20241225190612025](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412251906178.png)

请求参数是：![image-20241225190637686](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412251906784.png)

返回值是：![image-20241225190656173](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202412251906270.png)

前面从controller开始的部分没有难点，难点是serviceimpl的业务逻辑的实现和数据库查询语句的编写，由于存在菜品和套餐两种类型的购物车item，所以它俩查询数据库的SQL是不同的：

![image-20250104103201904](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202501041032151.png)

所以自然而然的，出于方便性的考虑，我们想要使用动态SQL来完成查询，这样就不用两句SQL都写。

### 查看购物车

查看购物车实现比较简单，查看接口文档，得知没有请求参数，但是要求返回数据，返回的是一个包含所有点餐的array，实际实现用的是集合List。

![image-20250114093901024](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202501140939203.png)

对应的是一件菜品或套餐的数据，刚好可以使用`shoppingCart`来存。

之前写过mapper里面的list方法，用于动态生成SQL语句，这里直接调用即可，where子句里传的是userId，实现很简单。

### 清空购物车

清空购物车的功能和删除购物车中一个物品的功能不同，前者是DELETE，后者实质是修改和删除，当数量为1的时候才删除，大于1就修改number字段。所以清空购物车仅仅只是进行了数据库的删除操作，根据什么来删？应该根据userId来删，这个数据从baseContext中拿，传给mapper层中的方法进行删除即可。

![image-20250115090358997](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202501150903176.png)

## Day 8 

### 地址簿模块

![image-20250115090536590](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202501150905696.png)

相关的功能是重复的增删改查操作，有两个接口对应的是一个功能，那就是删除操作之前需要进行回显。

还有另一个点，设置默认地址的问题。设置一个地址为默认地址时其他的地址应该自动解除默认地址的状态，也就是说在设置新的默认地址之前，先解除旧的，粗暴一点就是先设置所有的地址的isDefault字段都为0，再设置新的。

### 用户下单

用户下单的业务逻辑较为复杂，需要用到多张表的数据，比如一张订单小票里需要包含用户的地址数据，这个需要从地址簿中查；还需要包含送达时间、配送费、打包费等原本没有的信息，这些信息也可以放在后端中处理，可以暂时设置成常量，在后续迭代优化其逻辑；还需要订单的总金额信息，这个和之后的订单支付操作也相关，用到的是购物车中的数据。

接下来是数据库设计，一共设计了两张表，一个是订单表，另一个是订单明细表，订单表存储基本的信息，至于具体点了什么，点的物品的口味的信息，则需要到订单明细表中查。

![image-20250115093009727](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202501150930946.png)

根据提出的问题来研究需求。

![image-20250115092441813](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202501150924022.png)

注意设置一些**冗余字段**有助于后续操作，减少不必要的增删改查，但是也增加了改动的难度。

![image-20250115092639111](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202501150926331.png)

再看商品明细表，这个对应的是订单里的一个商品，可能一个订单对应的是对个订单明细，所以是一对多的关系。

![image-20250115093925823](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202501150939074.png)

![image-20250115093953083](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202501150939302.png)

#### controller具体实现

![image-20250118104210119](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202501181042287.png)

没什么好说的，注意返回Result需要带有泛型OrderSubmitVO即可。

#### service具体实现

controller调用的是service层的`submitOrder`方法，实现的过程中要注意业务逻辑，在用户点击“去结算”按钮之后，调用这个`submitOrder`方法，那么自然需要提交所有的购物车数据，存到订单表和订单明细表中去，这是最主要的逻辑。在此之前还需要进行有关业务异常的处理，比如购物车为空、地址为空（这个其实可以参考美团的逻辑，可以为空但是不能进一步进行支付，会要求填写地址）时应该throw相应的exception。在存好订单表和订单明细表之后，购物车的数据应该删除，最后封装对应的返回数据结构并返回。

**注意！**这一系列的操作是必须全部完成的，具有原子性，需要进行事务控制，要么全部完成，要么全部不完成。一定别忘记**在方法前面加上`@Transactional`注解**。

下面给出具体代码：

```java
@Service
public class OrderServiceImpl implements OrderService {
    @Autowired
    private OrderMapper orderMapper;
    @Autowired
    private OrderDetailMapper orderDetailMapper;
    @Autowired
    private AddressBookMapper addressBookMapper;
    @Autowired
    private ShoppingCartMapper shoppingCartMapper;

    /**
     * 用户下单
     * @param ordersSubmitDTO
     * @return
     */
    @Transactional
    public OrderSubmitVO submitOrder(OrdersSubmitDTO ordersSubmitDTO) {
        //1.在处理请求之前先处理各种业务异常（地址簿为空、购物车为空）
        AddressBook addressBook = addressBookMapper.getById(ordersSubmitDTO.getAddressBookId());
        if(addressBook==null){
            //抛出业务异常,使用地址簿
            throw new AddressBookBusinessException(MessageConstant.ADDRESS_BOOK_IS_NULL);
        }

        Long userId = BaseContext.getCurrentId();
        ShoppingCart shoppingCart=new ShoppingCart();
        shoppingCart.setUserId(userId);
        List<ShoppingCart> shoppingCartList = shoppingCartMapper.list(shoppingCart);
        if (shoppingCartList == null || shoppingCartList.size() == 0) {
            throw new AddressBookBusinessException(MessageConstant.SHOPPING_CART_IS_NULL);
        }

        //2.向订单表插入1条数据
        Orders orders=new Orders();
        BeanUtils.copyProperties(ordersSubmitDTO,orders);
        orders.setOrderTime(LocalDateTime.now());
        orders.setPayStatus(Orders.UN_PAID);
        orders.setStatus(Orders.PENDING_PAYMENT);
        orders.setNumber(String.valueOf(System.currentTimeMillis()));//订单号根据时间戳创建
        orders.setPhone(addressBook.getPhone());
        orders.setConsignee(addressBook.getConsignee());
        orders.setUserId(userId);

        orderMapper.insert(orders);

        //3.向订单明细表插入1或多条数据,需要用到前面的主键值
        List<OrderDetail> orderDetailList=new ArrayList<>();
        for(ShoppingCart cart:shoppingCartList){
            OrderDetail orderDetail=new OrderDetail();
            BeanUtils.copyProperties(cart,orderDetail);
            orderDetail.setOrderId(orders.getId());//设置当前订单明细关联的订单ID
            orderDetailList.add(orderDetail);//对于订单数据进行批量插入,所以先把这些明细放到list集合里
        }
        orderDetailMapper.insertBatch(orderDetailList);

        //4.下单成功后清空购物车（根据UserId）数据
        shoppingCartMapper.deleteByUserId(userId);

        //5.封装VO返回结果
        OrderSubmitVO orderSubmitVO=OrderSubmitVO.builder()
                .id(orders.getId())
                .orderTime(orders.getOrderTime())
                .orderNumber(orders.getNumber())
                .orderAmount(orders.getAmount())
                .build();
        return orderSubmitVO;
    }
}
```



### 订单支付

开通微信支付的服务需要进行商户注册，这个作为普通的个人学生是无法完成的，因此只了解一下微信支付流程和接口的调用流程。

![image-20250118105811349](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202501181058547.png)

涉及两个问题，调用微信接口时如何确保安全？需要进行加密解密、签名，因此需要对应的证书。

![image-20250119085316931](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202501190853093.png)

第二，微信后台如何调用到商户系统？用到内网穿透，临时获取一个公网IP，这样就能通过HTTP请求的方式获取到商户系统的回应了。

![image-20250119085438016](https://gitee.com/De1ores/csdn-picture-bed/raw/master/202501190854161.png)

---

## Day 9

这一天是实战，主要任务为：

完成用户端**历史订单**模块、**商家端订单管理**模块相关业务新功能开发和已有功能优化，具体任务列表如下：

#### 1. 新功能开发

用户端历史订单模块：

- 查询历史订单
- 查询订单详情
- 取消订单
- 再来一单

商家端订单管理模块：

- 订单搜索
- 各个状态的订单数量统计
- 查询订单详情
- 接单
- 拒单
- 取消订单
- 派送订单
- 完成订单

#### 2. 已有功能优化

优化用户下单功能，加入校验逻辑，如果用户的收货地址距离商家门店超出配送范围（配送范围为5公里内），则下单失败。

提示：

​	1. 基于百度地图开放平台实现（https://lbsyun.baidu.com/）

​	2. 注册账号--->创建应用获取AK(服务端应用)--->调用接口

 3. 相关接口

    https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding

    https://lbsyun.baidu.com/index.php?title=webapi/directionlite-v1

 4. 商家门店地址可以配置在配置文件中，例如：

    ~~~yaml
    sky:
      shop:
        address: 北京市海淀区上地十街10号
    ~~~


### 历史订单查询

#### 业务规则

- 分页查询历史订单
- 可以根据订单状态查询
- 展示订单数据时，需要展示的数据包括：下单时间、订单状态、订单金额、订单明细（商品名称、图片）

#### serviceImpl

```java
/**
     * 用户端订单分页查询
     *
     * @param pageNum
     * @param pageSize
     * @param status
     * @return
     */
    public PageResult pageQuery4User(int pageNum, int pageSize, Integer status) {
        //基于SQL的limit关键字实现分页查询，后面的数字是具体的参数
        // select * from order limit 0,10

        // 设置分页
        PageHelper.startPage(pageNum, pageSize);

        OrdersPageQueryDTO ordersPageQueryDTO = new OrdersPageQueryDTO();
        ordersPageQueryDTO.setUserId(BaseContext.getCurrentId());
        ordersPageQueryDTO.setStatus(status);

        // 分页条件查询
        Page<Orders> page = orderMapper.pageQuery(ordersPageQueryDTO);

        //加工成期望的返回结果pageResult:一个是total，一个是record集合，难在record的封装
        //很明显要把Orders表和OrderDetail表中的数据封装在一个OrderVO中返回
        long total=page.getTotal();

        List<OrderVO> records=new ArrayList<>();
        // 查询出订单明细，并封装入OrderVO进行响应
        if (page != null && page.getTotal() > 0) {
            for (Orders orderItem : page) {
                Long orderId = orderItem.getId();// 订单id

                // 查询订单明细
                List<OrderDetail> orderDetails = orderDetailMapper.getByOrderId(orderId);

                OrderVO orderVO = new OrderVO();
                BeanUtils.copyProperties(orderItem, orderVO);
                orderVO.setOrderDetailList(orderDetails);

                records.add(orderVO);
            }
        }

        PageResult pageResult=new PageResult(total,records);
        return pageResult;

    }
```

#### xml

对应的是分页查询的逻辑，提供了按照下单时间查询和按照状态查询等功能。

```xml
<select id="pageQuery" resultType="com.sky.entity.Orders">
        select * from orders
        <where>
            <if test="number != null and number!=''">
                and number like concat('%',#{number},'%')
            </if>
            <if test="phone != null and phone!=''">
                and phone like concat('%',#{phone},'%')
            </if>
            <if test="userId != null">
                and user_id = #{userId}
            </if>
            <if test="status != null">
                and status = #{status}
            </if>
            <if test="beginTime != null">
#               这里的 &gt;= 表示大于或等于
                and order_time &gt;= #{beginTime}
            </if>
            <if test="endTime != null">
#               这里的 &lt;= 表示小于或等于
                and order_time &lt;= #{endTime}
            </if>
        </where>
        order by order_time desc
    </select>
```

### 取消订单

#### 业务规则

- 待支付和待接单状态下，用户可直接取消订单
- 商家已接单状态下，用户取消订单需电话沟通商家
- 派送中状态下，用户取消订单需电话沟通商家
- 如果在待接单状态下取消订单，需要给用户退款
- 取消订单后需要将订单状态修改为“已取消”

#### 

### 查询订单详情

### 再来一单
